{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"COMPILER",
				"COMPILER_LIB_PATH1"
			],
			[
				"COMPIL",
				"COMPILER_TRIPLET"
			],
			[
				"fun",
				"funbo8a"
			]
		]
	},
	"buffers":
	[
		{
			"file": "/Users/smwesten/SMWData/Source_Code/swb/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 3318,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/Users/smwesten/SMWData/Source_Code/swb/tests/general/CMakeLists.txt",
			"settings":
			{
				"buffer_size": 1269,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "!> @file\n!> Contains a single module, @ref model, which keeps track of the model date and executes\n!>  necessary process modules.\n\n!> Allocates memory to store intermediate and final calculation results,\n!> keeps track of the model date, reads tabular climate data, and calls the\n!> necessary process modules in turn.\nmodule model\n\n  use iso_c_binding, only : c_short, c_int, c_float, c_double\n  use types\n  use data_factory\n  use datetime\n  use swb_grid\n  use stats\n  use runoff_curve_number\n  use et_crop_coefficients\n  use et_thornthwaite_mather\n  use et_turc\n  use et_hargreaves\n  use et_jensen_haise\n  use et_blaney_criddle\n  use irrigation\n  use netcdf4_support\n  use sm_thornthwaite_mather\n  use snow\n  use water_balance\n\n   implicit none\n\n  !! Counter for moving average water inputs\n  integer (kind=c_int) :: iDayCtr\n\n  !! Generic grids used to shuffle data between subroutines\n  type ( T_GENERAL_GRID ),pointer :: pGenericGrd_int\n  type ( T_GENERAL_GRID ),pointer :: pGenericGrd_sgl\n\n  !! For the \"downhill\" solution\n  integer (kind=c_int) :: iOrderCount\n  integer (kind=c_int), dimension(:), allocatable :: iOrderCol\n  integer (kind=c_int), dimension(:), allocatable :: iOrderRow\n  real(kind=c_float) :: rStartTime,rEndTime\n\ncontains\n\n\n!--------------------------------------------------------------------------\n!!****s* model/model_Solve\n! NAME\n!   model_Solve - Reads and initializes model grids and executes process\n!                 subroutines.\n!\n! SYNOPSIS\n!   Reads and initializes model grids, reads climate data file, and handles\n!   calls each process subroutine on a daily basis.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!   pConfig - Pointer to the model configuration data structure.\n!\n! OUTPUTS\n!   NONE\n!\n!!***\n\nsubroutine model_Solve( pGrd, pConfig, pGraph, pLandUseGrid)\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd               ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig      ! pointer to data structure that contains\n    ! model options, flags, and other settings\n\n  type (T_GRAPH_CONFIGURATION), dimension(:), pointer :: pGraph\n    ! pointer to data structure that holds parameters for creating\n    ! DISLIN plots\n  type ( T_GENERAL_GRID ), pointer :: pLandUseGrid       ! pointer to land use grid\n\n  ! [ LOCALS ]\n  integer (kind=c_int) :: i, j, k, iStat, iDayOfYear, iMonth\n  integer (kind=c_int) :: tj, ti\n  integer (kind=c_int) :: iTempDay, iTempMonth, iTempYear\n  integer (kind=c_int) :: iPos\n  integer (kind=c_int) :: jj, ii, iNChange, iUpstreamCount, iPasses, iTempval\n  integer (kind=c_int) :: iCol, iRow\n  character(len=3) :: sMonthName\n  logical (kind=c_bool) :: lMonthEnd\n  integer (kind=c_int),save :: iNumGridCells\n\n  real (kind=c_float) :: rmin,ravg,rmax\n\n  type (T_CELL),pointer :: cel\n  character (len=256) :: sBuf\n\n  type (T_TIME_SERIES_FILE), pointer :: pTS\n\n  ! allocate memory for the time-series data pointer\n  ALLOCATE (pTS, STAT=iStat)\n  call Assert( iStat == 0, &\n    \"Could not allocate memory for time-series data structure\", &\n    TRIM(__FILE__),__LINE__)\n\n  pConfig%iNumDaysInYear = num_days_in_year(pConfig%iYear)\n\n  FIRST_YEAR: if(pConfig%lFirstYearOfSimulation) then\n\n    pGenericGrd_int => grid_Create ( pGrd%iNX, pGrd%iNY, pGrd%rX0, pGrd%rY0, &\n       pGrd%rX1, pGrd%rY1, DATATYPE_INT )\n\n    pGenericGrd_sgl => grid_Create ( pGrd%iNX, pGrd%iNY, pGrd%rX0, pGrd%rY0, &\n       pGrd%rX1, pGrd%rY1, DATATYPE_REAL )\n\n    call model_CheckConfigurationSettings( pGrd, pConfig )\n\n!    call model_InitializeInputAndOutput( pGrd, pConfig )\n\n    !> read in flow direction, soil group, and AWC grids\n    call model_InitializeDataStructures( pGrd, pConfig )\n\n    call model_InitializeInputAndOutput( pGrd, pConfig )\n\n   ! Are we solving using the downhill algorithm?\n    if ( pConfig%iConfigureRunoffMode == CONFIG_RUNOFF_DOWNHILL ) then\n      ! if a routing table exists, read it in; else initialize and\n      ! save the routing table for future use\n      write(UNIT=LU_LOG,FMT=*) \"Configuring runoff for the downhill flow routing option...\"\n      call model_ConfigureRunoffDownhill( pGrd, pConfig)\n    end if\n\n    ! Unless we are *not* routing water, we *must* call InitializeFlowDirection\n    if( pConfig%iConfigureRunoffMode /= CONFIG_RUNOFF_NO_ROUTING) then\n      write(UNIT=LU_LOG,FMT=*) \"Initializing flow direction...\"\n      call model_InitializeFlowDirection( pGrd , pConfig)\n    end if    !> any negative values are interpreted to mean that the cell should be\n    !> inactivated\n!    call model_setInactiveCells( pGrd, pConfig )\n\n    ! Initialize the model landuse-related parameters\n!    call model_InitializeLanduseRelatedParams( pGrd, pConfig )\n\n!    call model_InitializeRunoff( pGrd, pConfig )\n\n!    if (pConfig%lEnableIrrigation .and. &\n!      ( pConfig%iConfigureLanduse == CONFIG_LANDUSE_STATIC_GRID &\n!        .or. pConfig%iConfigureLanduse == CONFIG_LANDUSE_CONSTANT) ) then\n!      call model_CreateIrrigationTableIndex(pGrd, pConfig )\n!    endif\n\n    ! calculate number of gridcells here.\n    iNumGridCells = pGrd%iNX * pGrd%iNY\n\n  end if FIRST_YEAR\n\n  ! close any existing open time-series files...\n  close(LU_TS)\n\n  if(.not. pConfig%lGriddedData) then\n  ! Connect to the single-site time-series file\n    open ( LU_TS, file=pConfig%sTimeSeriesFilename, &\n      status=\"OLD\", iostat=iStat )\n    write(UNIT=LU_LOG,FMT=*)  \"Opening time series file: \", &\n      TRIM(pConfig%sTimeSeriesFilename)\n    flush(LU_LOG)\n    call Assert ( iStat == 0, &\n      \"Can't open time-series data file\" )\n!    pConfig%iCurrentJulianDay = pConfig%iCurrentJulianDay + 1\n    call gregorian_date(pConfig%iCurrentJulianDay, &\n      iTempYear, iTempMonth, iTempDay)\n    pConfig%iYear = iTempYear\n    pConfig%iMonth = iTempMonth\n    pConfig%iDay = iTempDay\n  end if\n\n  ! Zero out monthly and annual accumulators\n  call stats_InitializeMonthlyAccumulators()\n  call stats_InitializeAnnualAccumulators()\n\n  ! ***************************\n  ! ***** BEGIN MAIN LOOP *****\n  ! ***************************\n\n  MAIN_LOOP: do\n\n  ! new day: initialize stats accumulators\n  call stats_InitializeDailyAccumulators()\n\n  ! blow away any remnant climate values\n  pTS%rPrecip = iNO_DATA_NCDC\n  pTS%rRH = iNO_DATA_NCDC\n  pTS%rMaxT = iNO_DATA_NCDC\n  pTS%rMinT = iNO_DATA_NCDC\n  pTS%rWindSpd = iNO_DATA_NCDC\n  pTS%rMinRH = iNO_DATA_NCDC\n  pTS%rSunPct = iNO_DATA_NCDC\n  pTS%lEOF = lFALSE\n\n  ! if we are not using gridded climate data, here is where we read in\n  ! the current days' values from the single-site time series file.\n  if(.not. pConfig%lGriddedData) then\n\n    call model_ReadTimeSeriesFile(pConfig, pTS)\n    if(pTS%lEOF) then\n      close(unit=LU_TS)\n      exit MAIN_LOOP\n    end if\n\n  end if\n\n  call LookupMonth(pConfig%iMonth,pConfig%iDay,pConfig%iYear, &\n    pConfig%iDayOfYear,sMonthName,lMonthEnd)\n\n  ! initialize (or re-initialize) landuse-associated variables;\n  ! must be done whenever a new landuse grid is provided\n\n  call DAT(LANDUSE_DATA)%getvalues( pGrdBase=pGrd, iMonth=pConfig%iMonth, &\n    iDay=pConfig%iDay, iYear=pConfig%iYear )\n\n  if ( DAT(LANDUSE_DATA)%lGridHasChanged ) then\n    pGrd%Cells%iLandUse = pGrd%iData\n    DAT(LANDUSE_DATA)%lGridHasChanged = lFALSE\n\n    pGenericGrd_int%iData = pGrd%Cells%iLandUse\n    pGenericGrd_int%iMask = pGrd%iMask\n\n    call grid_WriteGrid(sFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Landuse_Grid_\" // &\n      trim(asCharacter(pConfig%iYear))//\"_\"//trim(asCharacter(pConfig%iMonth)) &\n      //\"_\"//trim(asCharacter(pConfig%iYear))// &\n      \".\"//trim(pConfig%sOutputFileSuffix), pGrd=pGenericGrd_int, iOutputFormat=pConfig%iOutputFormat )\n\n    call make_shaded_contour(pGrd=pGenericGrd_int, &\n      sOutputFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Landuse_Grid_\" // &\n      trim(asCharacter(pConfig%iYear))//\"_\"//trim(asCharacter(pConfig%iMonth)) &\n      //\"_\"//trim(asCharacter(pConfig%iYear))//\".png\", &\n      sTitleTxt=\"Landuse Grid\", &\n      sAxisTxt=\"Landuse Code\" )\n\n    call model_setInactiveCells( pGrd, pConfig )\n\n    ! (Re)-initialize the model\n    call model_InitializeLanduseRelatedParams( pGrd, pConfig )\n    call sm_thornthwaite_mather_UpdatePctSM( pGrd )\n\n    if (pConfig%lEnableIrrigation .and. &\n      ( pConfig%iConfigureLanduse == CONFIG_LANDUSE_STATIC_GRID &\n        .or. pConfig%iConfigureLanduse == CONFIG_LANDUSE_CONSTANT) ) then\n      call model_CreateIrrigationTableIndex(pGrd, pConfig )\n    endif\n\n    write(UNIT=LU_LOG,FMT=*)  \"model.F90: model_InitializeET\"\n    flush(unit=LU_LOG)\n    call model_InitializeET( pGrd, pConfig )\n\n  endif\n\n  if(pConfig%lFirstDayOfSimulation) then\n    ! scan through list of potential output variables; if any\n    ! output is desired for a variable, note the current position\n    ! within the file, move to the position reserved for the first day's\n    ! date, write the date, and return to the position where the data\n    ! for the first day will be written\n    do k=1,iNUM_VARIABLES\n      if(STAT_INFO(k)%iDailyOutput > iNONE &\n        .or. STAT_INFO(k)%iMonthlyOutput > iNONE &\n        .or. STAT_INFO(k)%iAnnualOutput > iNONE)  then\n        inquire(UNIT=STAT_INFO(k)%iLU,POS=iPos)  ! establish location to return to\n        write(UNIT=STAT_INFO(k)%iLU,POS=iSTARTDATE_POS) &\n          pConfig%iMonth,pConfig%iDay, pConfig%iYear\n        write(UNIT=STAT_INFO(k)%iLU,POS=iPos ) ! return to prior location in bin file\n      end if\n      pConfig%lFirstDayOfSimulation = lFALSE\n    end do\n\n  end if\n\n  if(pConfig%lWriteToScreen) then\n    write(UNIT=LU_STD_OUT,FMT=*)\n    if(pConfig%lANSI_Colors) then\n      write(UNIT=LU_STD_OUT,FMT=\"(1x,a7,a80,a7)\") sBOLDWHITE,REPEAT('=',80),sWHITE\n    else\n      write(UNIT=LU_STD_OUT,FMT=\"(1x,a80)\") REPEAT('=',80)\n    end if\n    write(UNIT=LU_STD_OUT,FMT=\"(1x,'DAY: ',i3,4x,A3,4x,i2,'/',i2,'/',i4)\") &\n      pConfig%iDayOfYear,sMonthName,pConfig%iMonth,pConfig%iDay,pConfig%iYear\n!      write(UNIT=LU_STD_OUT,FMT=\"(1x,a80)\") REPEAT('-',80)\n    write(UNIT=LU_STD_OUT,FMT=*)\n  end if\n\n  ! write timestamp to the unformatted fortran file(s)\n  do k=1,iNUM_VARIABLES\n    if(STAT_INFO(k)%iDailyOutput > iNONE &\n      .or. STAT_INFO(k)%iMonthlyOutput > iNONE &\n      .or. STAT_INFO(k)%iAnnualOutput > iNONE)  then\n    write(UNIT=STAT_INFO(k)%iLU) pConfig%iDay,pConfig%iMonth, &\n      pConfig%iYear, pConfig%iDayOfYear\n!    inquire(UNIT=STAT_INFO(k)%iLU, POS=STAT_INFO(k)%iPos)\n!    write(UNIT=STAT_INFO(k)%iLU) iNO_DATA_NCDC  ! dummy value for now\n    end if\n  end do\n\n!***********************************************************************\n\n!  ! Initialize precipitation value for current day\n  call model_GetDailyPrecipValue(pGrd, pConfig, pTS%rPrecip, &\n    pConfig%iMonth, pConfig%iDay, pConfig%iYear, pConfig%iCurrentJulianDay)\n\n  ! Initialize temperature values for current day\n  call model_GetDailyTemperatureValue(pGrd, pConfig, &\n    pTS%rAvgT, pTS%rMinT, pTS%rMaxT, pTS%rRH, &\n    pConfig%iMonth, pConfig%iDay, pConfig%iYear, pConfig%iCurrentJulianDay)\n\n  write(UNIT=LU_LOG,FMT=\"(1x,'Beginning calculations for day: ',\" &\n    //\"i3,4x,A3,4x,i2,'/',i2,'/',i4)\") &\n    pConfig%iDayOfYear,sMonthName,pConfig%iMonth,pConfig%iDay,pConfig%iYear\n\n  if(pConfig%lWriteToScreen) then\n    write(UNIT=LU_STD_OUT,FMT=\"(t39,a,t53,a,t69,a)\") \"min\",\"mean\",\"max\"\n    call stats_WriteMinMeanMax(LU_STD_OUT,\"Gross Precipitation (in)\" , pGrd%Cells(:,:)%rGrossPrecip )\n    call stats_WriteMinMeanMax(LU_STD_OUT,\"Minimum Temp (F)\" , pGrd%Cells(:,:)%rTMin )\n    call stats_WriteMinMeanMax(LU_STD_OUT,\"Mean Temp (F)\" , pGrd%Cells(:,:)%rTAvg )\n    call stats_WriteMinMeanMax(LU_STD_OUT,\"Maximum Temp (F)\" , pGrd%Cells(:,:)%rTMax )\n!      write(UNIT=LU_STD_OUT,FMT=\"(1x,a80)\") REPEAT('-',80)\n  write(UNIT=LU_STD_OUT,FMT=*)\nend if\n\n  call model_UpdateContinuousFrozenGroundIndex( pGrd , pConfig)\n\n  call model_UpdateGrowingSeason( pGrd, pConfig )\n\n  if(pConfig%iConfigureSnow == CONFIG_SNOW_ORIGINAL_SWB) then\n    call model_ProcessRain(pGrd, pConfig, pConfig%iDayOfYear, pConfig%iMonth)\n  else if(pConfig%iConfigureSnow == CONFIG_SNOW_NEW_SWB) then\n    call model_ProcessRainPRMS(pGrd, pConfig, pConfig%iDayOfYear, &\n      pConfig%iMonth, pConfig%iNumDaysInYear)\n  else\n    call Assert(lFALSE,\"Unhandled snow module option specified\", &\n      TRIM(__FILE__),__LINE__)\n  end if\n\n  call model_ProcessET( pGrd, pConfig, pConfig%iDayOfYear, &\n    pConfig%iNumDaysInYear, pTS%rRH, pTS%rMinRH, &\n    pTS%rWindSpd, pTS%rSunPct )\n\n  if(pConfig%iConfigureFAO56 /= CONFIG_FAO56_NONE ) then\n    call model_UpdateGrowingDegreeDay( pGrd , pConfig)\n    call et_kc_ApplyCropCoefficients(pGrd, pConfig)\n  endif\n\n  if( pConfig%lEnableIrrigation )  call irrigation_UpdateAmounts(pGrd, pConfig)\n\n  call model_ProcessRunoff(pGrd, pConfig, pConfig%iDayOfYear, pConfig%iMonth)\n\n  call calculate_water_balance( pGrd, pConfig, pConfig%iDayOfYear, &\n    pConfig%iDay ,pConfig%iMonth, pConfig%iYear)\n\n  ! if desired, output daily mass balance file and daily model grids\n  if(pConfig%lWriteToScreen) then\n    call stats_DumpDailyAccumulatorValues(LU_STD_OUT, pConfig)\n  else\n    write(UNIT=LU_STD_OUT,FMT=\"(a,i2.2,a,i2.2,a,i4.4)\") &\n      \"Simulation day: \",pConfig%iMonth,\"/\", pConfig%iDay, \"/\", pConfig%iYear\n  end if\n\n  ! if desired, output daily mass balance file and daily model grids\n  if ( pConfig%lReportDaily ) then\n\n    call stats_WriteDailyAccumulatorValuesCSV(LU_CSV_MIN,pConfig%iMonth, &\n      pConfig%iDay,pConfig%iYear,iMIN)\n    call stats_WriteDailyAccumulatorValuesCSV(LU_CSV_MEAN,pConfig%iMonth, &\n      pConfig%iDay,pConfig%iYear,iMEAN)\n    call stats_WriteDailyAccumulatorValuesCSV(LU_CSV_MAX,pConfig%iMonth, &\n      pConfig%iDay,pConfig%iYear,iMAX)\n    call stats_WriteMSBReport(pGrd,pConfig%iMonth,pConfig%iDay, &\n      pConfig%iYear,pConfig%iDayOfYear)\n\n  end if\n\n  call model_WriteGrids(pGrd=pGrd, pConfig=pConfig, iOutputType=WRITE_ASCII_GRID_DAILY)\n\n  ! Write the results at each month-end\n  if ( lMonthEnd ) then\n\n    call model_WriteGrids(pGrd=pGrd, pConfig=pConfig, iOutputType=WRITE_ASCII_GRID_MONTHLY)\n\n  if ( pConfig%lWriteToScreen) call stats_DumpMonthlyAccumulatorValues(LU_STD_OUT, &\n    pConfig%iMonth, sMonthName, pConfig)\n\n    write(UNIT=LU_LOG,FMT=\"(A,i2,A,i4)\") &\n      \"finished monthly calculations for: \", &\n        pConfig%iMonth, \"/\", pConfig%iYear\n    flush(UNIT=LU_LOG)\n\n  end if\n\n  !-------------------------------------------------------------------------\n  ! time control block follows; if next day is part of a new year, exit loop\n  !-------------------------------------------------------------------------\n  call gregorian_date(pConfig%iCurrentJulianDay + 1, &\n    iTempYear, iTempMonth, iTempDay)\n\n  call MODEL_SIM%addDay()\n\n  if(pConfig%iYear /= iTempYear) then\n    close(unit=LU_TS)\n    exit MAIN_LOOP\n  else\n    pConfig%iMonth = iTempMonth\n    pConfig%iDay = iTempDay\n    pConfig%iCurrentJulianDay = pConfig%iCurrentJulianDay + 1\n  end if\n\n  end do MAIN_LOOP\n\n\n  call model_WriteGrids(pGrd=pGrd, pConfig=pConfig, iOutputType=WRITE_ASCII_GRID_ANNUAL)\n\n  ! model_Solve has been called once... any further calls will not require\n  !    re-initialization of data structures and data arrays\n  pConfig%lFirstYearOfSimulation = lFALSE\n\n  if(pConfig%lWriteToScreen) &\n    call stats_DumpAnnualAccumulatorValues(LU_STD_OUT, pConfig, pConfig%iYear)\n\n  call stats_WriteAnnualAccumulatorValuesCSV(LU_CSV_ANNUAL,pConfig%iYear)\n\n  ! update value of last year\n  if( .not. pConfig%lGriddedData) pConfig%iEndYear = pConfig%iYear\n\n  ! update current date so all is well when next years file is opened\n  pConfig%iMonth = iTempMonth\n  pConfig%iDay = iTempDay\n  pConfig%iCurrentJulianDay = pConfig%iCurrentJulianDay + 1\n\n\n  DEALLOCATE(pTS, STAT=iStat)\n  call Assert( iStat == 0, &\n    \"Could not deallocate memory for time-series data structure\")\n\nend subroutine model_Solve\n\n!!***\n\n!--------------------------------------------------------------------------\n!!****s* model/model_EndOfRun\n! NAME\n!   model_EndOfRun - Closes fortran files units and prints out elapsed runtime.\n!\n! SYNOPSIS\n!   Closes fortran files units and prints out elapsed runtime.\n!\n! INPUTS\n!   pConfig - Pointer to the model configuration data structure.\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   Code refers to parameters that are set within types.f95.\n!\n! SOURCE\n\nsubroutine model_EndOfRun(pGrd, pConfig, pGraph)\n\n  ![ARGUMENTS]\n  type (T_GENERAL_GRID),pointer :: pGrd      ! Grid of model cells\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig  ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  type (T_GRAPH_CONFIGURATION), dimension(:), pointer :: pGraph\n    ! pointer to data structure that holds parameters for creating\n    ! DISLIN plots\n\n  ![LOCALS]\n  integer (kind=c_int) :: iIndex\n\n  ! finalize and close any open NetCDF or binary output files\n  do iIndex=1,iNUM_VARIABLES\n\n    ! write the end date of the simulation into the header of\n    ! the binary file (*.bin)\n    if(STAT_INFO(iIndex)%iDailyOutput > iNONE &\n      .or. STAT_INFO(iIndex)%iMonthlyOutput > iNONE &\n      .or. STAT_INFO(iIndex)%iAnnualOutput > iNONE)  then\n      write(UNIT=STAT_INFO(iIndex)%iLU,POS=iENDDATE_POS) &\n        pConfig%iMonth,pConfig%iDay, pConfig%iYear\n    end if\n\n  end do\n\n  ! clean up\n  close ( unit=LU_TS )\n  if ( pConfig%lReportDaily ) then\n    close ( unit=LU_MSB_REPORT )\n    close ( unit=LU_CSV_MIN )\n    close ( unit=LU_CSV_MEAN )\n    close ( unit=LU_CSV_MAX )\n    close ( unit=LU_CSV_ANNUAL )\n  end if\n\n  ! close any binary output files\n  call stats_CloseBinaryFiles()\n\n  ! trigger the call to reconstitute the output grids and plots from the\n  ! compressed binary files, if desired\n  if(.not. pConfig%lUseSWBRead) &\n    call stats_RewriteGrids(pGrd%iNX, pGrd%iNY, pGrd%rX0, pGrd%rY0, pGrd%rX1, &\n      pGrd%rY1, pConfig, pGraph)\n\n  ! destroy model grid to free up memory\n  call grid_Destroy(pGrd)\n  call grid_Destroy(pGenericGrd_int)\n  call grid_Destroy(pGenericGrd_sgl)\n!  call grid_Destroy(pGenericGrd_short)\n\n  do iIndex=1,size(DAT, 1)\n    if (DAT(iIndex)%iNC_ARCHIVE_STATUS == NETCDF_FILE_OPEN ) then\n      call netcdf_close_file(NCFILE=DAT(iIndex)%NCFILE_ARCHIVE)\n      call netcdf_deallocate_data_struct(NCFILE=DAT(iIndex)%NCFILE_ARCHIVE)\n    endif\n  enddo\n\n  ! how long did all this take, anyway?\n  call cpu_time(rEndTime)\n  print \"(//1x,'SWB run completed in: ',f10.2,' minutes')\", &\n    (rEndTime - rStartTime) / 60.0_c_float\n  write(unit=LU_LOG,fmt=\"(//1x,'SWB run completed in: ',f10.2, ' minutes')\"), &\n    (rEndTime - rStartTime) / 60.0_c_float\n\n  return\nend subroutine model_EndOfRun\n\n!--------------------------------------------------------------------------\n!!****s* model/model_GetDailyPrecipValue\n! NAME\n!   model_GetDailyPrecipValue - Copies precipitation values into\n!                               the cell-by-cell data structure.\n!\n! SYNOPSIS\n!   Populates the gross precipitation value on a cell-by-cell basis.\n!   If gridded precipitation data are used, this subroutine reads in the\n!   daily precipitation grid and copies the values into the cell-by-cell\n!   data structure.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!   pConfig - Pointer to the model configuration data structure.\n!   rPrecip - Daily precipitation amount read in by model_Solve.\n!   iDayOfYear - Day of the current year (January 1 = 1).\n!   iMonth - Month corresponding to the current model day (January = 1).\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\n\nsubroutine model_GetDailyPrecipValue( pGrd, pConfig, rPrecip, iMonth, iDay, iYear, iJulianDay)\n  !! Populates Gross precipitation value on a cell-by-cell basis\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd        ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  real (kind=c_float), intent(in) :: rPrecip\n  integer (kind=c_int), intent(in) :: iMonth\n  integer (kind=c_int), intent(in) :: iDay\n  integer (kind=c_int), intent(in) :: iYear\n  integer (kind=c_int), intent(in) :: iJulianDay\n  ! [ LOCALS ]\n  real (kind=c_double) :: rMin, rMean, rMax, rSum\n  integer (kind=c_int) :: iCount, iNegCount\n  character (len=256) sBuf\n\n\n  call DAT(PRECIP_DATA)%set_constant(rPrecip)\n\n  call DAT(PRECIP_DATA)%getvalues( pGrdBase=pGrd, &\n      iMonth=iMonth, iDay=iDay, iYear=iYear, &\n      iJulianDay=iJulianDay, &\n      rValues=pGrd%Cells%rGrossPrecip)\n\n  write(sBuf, fmt=\"(i4.4,'_',i2.2,'_',i2.2)\") iYear, iMonth, iDay\n\n!  pGrd%Cells%rGrossPrecip = pGrd%rData\n\n  iNegCount = COUNT(pGrd%Cells%rGrossPrecip < pConfig%rMinValidPrecip)\n\n  ! convert values less than the minimum valid amount to zero\n  where (pGrd%Cells%rGrossPrecip < pConfig%rMinValidPrecip)\n    pGrd%Cells%rGrossPrecip = rZERO\n  end where\n\n!  pGenericGrd_sgl%rData = pGrd%Cells%rGrossPrecip\n!\n!  call make_shaded_contour(pGrd=pGenericGrd_sgl, &\n!     sOutputFilename=trim(pConfig%sOutputFilePrefix) // \"Precip_\"//trim(sBuf)//\".png\", &\n!     sTitleTxt=\"Precip: \"//trim(sBuf), &\n!     sAxisTxt=\"mm per day\" )\n\n  if(pConfig%lHaltIfMissingClimateData) then\n    call Assert(rMin >= rZERO,\"Precipitation values less than \" &\n      //real2char(pConfig%rMinValidPrecip)//\" are not allowed. \" &\n      //\"(\"//trim(int2char(iNegCount))//\" cells with values < \" &\n      //real2char(pConfig%rMinValidPrecip)//\")\",TRIM(__FILE__),__LINE__)\n  elseif(iNegCount > 0) then\n    write(sBuf,fmt=\"(a,i7,1x,a,1x,i2.2,'/',i2.2,'/',i4.4)\") \"*** \",iNegCount, &\n      \"Missing PRECIPITATION values detected: \", iMonth, iDay, iYear\n    call echolog(sBuf)\n    call echolog(\"  ==> Missing precipitation values will be set to zero\")\n  endif\n\n  rMin = minval(pGrd%Cells%rGrossPrecip)\n  rMax = maxval(pGrd%Cells%rGrossPrecip)\n  rSum = sum(pGrd%Cells%rGrossPrecip)\n  iCount = size(pGrd%Cells%rGrossPrecip)\n\n  ! We are ignoring any missing or bogus values in this calculation\n  rMean = rSum / iCount\n\n  call stats_UpdateAllAccumulatorsByGrid(rMin,rMean,rMax,rSum,iGROSS_PRECIP,iMonth)\n\nend subroutine model_GetDailyPrecipValue\n\n!!***\n\n!--------------------------------------------------------------------------\n!!****s* model/model_GetDailyTemperatureValue\n! NAME\n!   model_GetDailyTemperatureValue - Copies precipitation values into\n!                               the cell-by-cell data structure.\n!\n! SYNOPSIS\n!   Populates the minimum, maximum, and average temperature values\n!   on a cell-by-cell basis.\n!\n!   If gridded temperature data are used, this subroutine reads in the\n!   daily minimum and maximum temperature grid and copies the values\n!   into the cell-by-cell data structure.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!   pConfig - Pointer to the model configuration data structure.\n!   rAvgT - Average daily temperature in Fahrenheit.\n!   rMinT - Minimum daily temperature in Fahrenheit.\n!   rMaxT - Maximum daily temperature in Fahrenheit.\n!   iMonth - Month corresponding to the current model day (January = 1).\n!   iDay - Day of month\n!   iYear - Year\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\n\nsubroutine model_GetDailyTemperatureValue( pGrd, pConfig, rAvgT, rMinT, &\n  rMaxT, rRH, iMonth, iDay, iYear, iJulianDay)\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd        ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  real (kind=c_float), intent(in) :: rAvgT\n  real (kind=c_float), intent(in) :: rMinT\n  real (kind=c_float), intent(in) :: rMaxT\n  real (kind=c_float), intent(in) :: rRH\n  integer (kind=c_int), intent(in) :: iMonth\n  integer (kind=c_int), intent(in) :: iDay\n  integer (kind=c_int), intent(in) :: iYear\n  integer (kind=c_int), intent(in) :: iJulianDay\n\n  ! [ LOCALS ]\n  real (kind=c_double) :: rMin, rMean, rMax, rSum, rTFactor, rTempVal, rMeanTMIN, rMeanTMAX\n  integer (kind=c_int) :: iNumGridCells\n  integer (kind=c_int) :: iRow,iCol, iCount, iCount_valid\n  character (len=256) sBuf\n  type (T_CELL),pointer :: cel\n\n  iCount = 0\n\n!$OMP PARALLEL SECTIONS\n!$OMP SECTION\n  call DAT(TMAX_DATA)%set_constant(rMaxT)\n  call DAT(TMAX_DATA)%getvalues( pGrdBase=pGrd, &\n      iMonth=iMonth, iDay=iDay, iYear=iYear, &\n      iJulianDay=iJulianDay, rValues=pGrd%Cells%rTMax)\n!OMP SECTION\n  call DAT(TMIN_DATA)%set_constant(rMinT)\n  call DAT(TMIN_DATA)%getvalues( pGrdBase=pGrd, &\n      iMonth=iMonth, iDay=iDay, iYear=iYear, &\n      iJulianDay=iJulianDay, rValues=pGrd%Cells%rTMin)\n!$OMP END PARALLEL SECTIONS\n\n\n#ifdef STREAM_INTERACTIONS\n  !! Adjust cell-by-cell temperature\n  if ( pconfig%lElevAdjustment ) then\n    do iRow=1, pGrd%iNX\n      do iCol=1, pGrd%iNY\n        cel => pGrd%Cells(iCol,iRow)\n        if ( pConfig%rElevHumidityThreshold > 9990.0_c_float .or. rRH < 0.0_c_float ) then\n          rTFactor = pConfig%rElevDryFactor\n        else if ( rRH < pConfig%rElevHumidityThreshold ) then\n          rTFactor = pConfig%rElevDryFactor\n        else\n          rTFactor = pConfig%rElevHumidFactor\n        end if\n        cel%rTMin = cel%rTMin - rTFactor * (cel%rElevation - pconfig%rElevStationElevation)\n        cel%rTMax = cel%rTMax - rTFactor * (cel%rElevation - pconfig%rElevStationElevation)\n        cel%rTAvg = cel%rTAvg - rTFactor * (cel%rElevation - pconfig%rElevStationElevation)\n      end do\n    end do\n  end if\n#endif\n\n  if(pConfig%lHaltIfMissingClimateData) then\n\n    call Assert(iCount == 0,\"Temperature values less than \" &\n      //real2char(pConfig%rMinValidTemp)//\" are not allowed. \" &\n      //\"(\"//trim(int2char(iCount) )//\" cells with values < \" &\n      //real2char(pConfig%rMinValidTemp)//\")\",TRIM(__FILE__),__LINE__)\n\n  elseif(iCount > 0) then\n\n    write(sBuf,fmt=\"(a,i7,1x,a,1x,i2.2,'/',i2.2,'/',i4.4)\") \"*** \",iCount, &\n      \"Missing minimum or maximum TEMPERATURE values detected: \", iMonth, iDay, iYear\n    call echolog(sBuf)\n    write(sBuf,fmt=\"(a,f12.3,a)\") \"  ==> Missing TMIN values will be \" &\n    //\"replaced with the mean of the remaining non-missing values (\", &\n    rMeanTMIN,\")\"\n\n    call echolog(sBuf)\n\n    write(sBuf,fmt=\"(a,f12.3,a)\") \"  ==> Missing TMAX values will be \" &\n    //\"replaced with the mean of the remaining non-missing values (\", &\n    rMeanTMAX,\")\"\n\n    call echolog(sBuf)\n\n  endif\n\n  pGrd%Cells%rTAvg = (pGrd%Cells%rTMax + pGrd%Cells%rTMin) / 2_c_float\n\n  ! Scan through array of inputs looking for instances where the TMIN > TMAX\n  ! (THIS CAN BE RE_WRITTEN USING MATRIX NOTATION)\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX\n      cel=>pGrd%Cells(iCol,iRow)\n\n      if( cel%rTMax < cel%rTMin )then\n\n        ! swap min and max values to maintain a positive delta T\n        rTempVal = cel%rTMax\n        cel%rTMax = cel%rTMin\n        cel%rTMin = cel%rTMax\n\n      end if\n\n      if (cel%rTMin > 29.) then\n        cel%rGDD_29F = cel%rGDD_29F + (cel%rTMin - 29.)\n      else\n        cel%rGDD_29F = 0.\n      endif\n\n    end do\n  end do\n\nend subroutine model_GetDailyTemperatureValue\n!!***\n!--------------------------------------------------------------------------\n!!****s* model/model_UpdateContinuousFrozenGroundIndex( pGrd )\n! NAME\n!   model_UpdateContinuousFrozenGroundIndex - Updates the continuous\n!                               frozen ground index on a cell-by-cell basis.\n! SYNOPSIS\n!   Updates the continuous frozen ground index (CFGI)\n!   on a cell-by-cell basis.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\n\nsubroutine model_UpdateContinuousFrozenGroundIndex( pGrd , pConfig)\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd        ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n\n  ! [ LOCALS ]\n  real (kind=c_float) :: A = 0.97             ! decay coefficient\n  integer (kind=c_int) :: iCol,iRow               ! temporary array indices\n  type (T_CELL),pointer :: cel              ! pointer to a particular cell\n  real (kind=c_float) :: rTAvg_C              ! temporary variable holding avg temp in C\n  real (kind=c_float) :: rSnowDepthCM         ! snow depth in centimeters\n\n  !$OMP DO ORDERED\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX\n      cel => pGrd%Cells(iCol,iRow)\n\n      if (pGrd%iMask(iCol, iRow) == iINACTIVE_CELL) cycle\n\n      rTAvg_C = FtoC(cel%rTAvg)\n      ! assuming snow depth is 10 times the water content of the snow in inches\n      rSnowDepthCM = cel%rSnowCover * 10.0_c_float * rCM_PER_INCH\n\n  if(cel%rTAvg > rFREEZING) then\n    cel%rCFGI = max(A*cel%rCFGI - &\n      (rTAvg_C * exp (-0.4_c_float * 0.5_c_float * rSnowDepthCM)),rZERO)\n  else ! temperature is below freezing\n    cel%rCFGI = max(A*cel%rCFGI - &\n      (rTAvg_C * exp (-0.4_c_float * 0.08_c_float * rSnowDepthCM)),rZERO)\n  end if\n\n  end do\nend do\n\n  !$OMP END DO\n\n!  write(UNIT=LU_LOG,FMT=*)  \"=========CFGI CALCULATION===========\"\n!  write(UNIT=LU_STD_OUT,FMT=\"(A)\") &\n!      \"                                 min          mean           max\"\n!  call stats_WriteMinMeanMax(LU_STD_OUT,\"CFGI\" , pGrd%Cells(:,:)%rCFGI )\n!\n!  write(UNIT=LU_LOG,FMT=*)  \"=========CFGI CALCULATION===========\"\n\n\n\nend subroutine model_UpdateContinuousFrozenGroundIndex\n\n\nsubroutine model_UpdateGrowingSeason( pGrd, pConfig )\n\n  implicit none\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd        ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n\n  ! [ LOCALS ]\n  type (T_CELL),pointer :: cel              ! pointer to a particular cell\n  integer (kind=c_int) :: iCol, iRow\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX\n      cel => pGrd%Cells(iCol, iRow)\n\n      if ( cel%lGrowingSeason ) then\n\n        if ( cel%rGDD_29F <= 50. ) cel%lGrowingSeason = lFALSE\n\n      else  ! it is NOT growing season\n\n        if ( cel%rGDD_29F > 50. ) cel%lGrowingSeason = lTRUE\n\n      endif\n\n    enddo\n  enddo\n\nend subroutine model_UpdateGrowingSeason\n\n\n!--------------------------------------------------------------------------\n!!****s* model/model_UpdateGrowingDegreeDay( pGrd )\n! NAME\n!   model_UpdateGrowingDegreeDay - Updates the growing degree-day\n!                                  on a cell-by-cell basis.\n! SYNOPSIS\n!   Updates the growing degree-day\n!   on a cell-by-cell basis.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\nsubroutine model_UpdateGrowingDegreeDay( pGrd , pConfig)\n\n  implicit none\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd        ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  ! [ LOCALS ]\n  real (kind=c_float) :: rDD                        ! daily departure from TBase\n  type (T_CELL),pointer :: cel                      ! pointer to a particular cell\n  real (kind=c_float) :: rA, rAt\n  real (kind=c_float) :: rTMax\n  real (kind=c_float) :: rW\n  integer (kind=c_int) :: iCol,iRow\n  real (kind=c_float) :: rGDD_BaseTemp, rGDD_MaxTemp\n  logical (kind=c_bool) :: lAssertTest\n\n  ! zero out growing degree day at start of calendar year\n!  if(pConfig%iDayOfYear == 1) pGrd%Cells%rGDD = 0.\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX  ! last subscript in a Fortran array should be the slowest-changing\n      cel => pGrd%Cells(iCol,iRow)\n\n      if (pGrd%iMask(iCol, iRow) == iINACTIVE_CELL) cycle\n\n      ! cap the maximum value used in GDD calculations on the basis of the value\n      ! provided by user...\n\n      lAssertTest = cel%iLandUseIndex >= 1 .and. cel%iLandUseIndex <= pConfig%iNumberOfLanduses\n\n      if(.not. lAssertTest) &\n        call assert(lAssertTest, &\n        \"Array index out of bounds. Variable is iLandUseIndex with a value of \" &\n        //trim(int2char(cel%iLandUseIndex)), trim(__FILE__),__LINE__)\n\n      rGDD_BaseTemp = pConfig%IRRIGATION(cel%iLandUseIndex)%rGDD_BaseTemp\n      rGDD_MaxTemp = pConfig%IRRIGATION(cel%iLandUseIndex)%rGDD_MaxTemp\n\n      rTMax = min(rGDD_MaxTemp, cel%rTMax)\n\n      if(rTMax <= rGDD_BaseTemp) then\n\n        rDD = 0.\n\n      elseif(cel%rTMin >= rGDD_BaseTemp) then\n\n        rDD = cel%rTAvg - rGDD_BaseTemp\n\n      else\n\n        rW = (rTMax - cel%rTMin) / 2.\n\n        rAt = ( rGDD_BaseTemp - cel%rTAvg) / rW\n\n        if(rAt > 1) rAt = 1.\n        if(rAt < -1) rAt = -1.\n\n        rA = asin(rAt)\n\n        rDD = (( rW * cos(rA)) - ((rGDD_BaseTemp - cel%rTAvg) &\n               * ((dpPI / 2.) - rA))) / dpPI\n\n      end if\n\n      cel%rGDD = cel%rGDD + rDD\n\n    end do\n\n  end do\n\nend subroutine model_UpdateGrowingDegreeDay\n\n!!***\n!--------------------------------------------------------------------------\n!!****s* model/model_ProcessRain\n! NAME\n!   model_ProcessRain - Processes the daily rainfall. Upon return, the\n!                       daily precipitation is corrected to account for\n!                       snow accumulation / snowmelt.\n!\n! SYNOPSIS\n!   Processes daily precipitation values. Daily precipitation values\n!   are altered to account for interception and with regard to the\n!   form that the precipitation takes (rain or snow). If the form of the\n!   precipitation is snow, the net precipitation value is zeroed out, and\n!   the precipitation value is moved into the snowfall value.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!   pConfig - Pointer to the model configuration data structure.\n!   iDayOfYear - Day of the current year (January 1 = 1).\n!   iMonth - Month corresponding to the current model day (January = 1).\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\n\nsubroutine model_ProcessRain( pGrd, pConfig, iDayOfYear, iMonth)\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd        ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  integer (kind=c_int),intent(in) :: iDayOfYear  ! Day of the year\n  integer (kind=c_int), intent(in) :: iMonth     ! Integer month value (1-12)\n  ! [ LOCALS ]\n  real (kind=c_double) :: dpPotentialMelt,dpPotentialInterception,dpInterception\n  real (kind=c_double) :: dpPreviousSnowCover,dpChgInSnowCover, dpSnowCover\n  real (kind=c_double) :: dpNetPrecip    ! all forms of precip, after interception\n  real (kind=c_double) :: dpNetRainfall  ! precip as RAINFALL, after interception\n  integer (kind=c_int) :: iRow, iCol\n  type (T_CELL),pointer :: cel\n  integer (kind=c_int) :: iNumGridCells\n  real (kind=c_double) :: rMin, rMean, rMax, rSum, rSum2\n  integer (kind=c_int) :: iRowCount\n  real (kind=c_float) ::  rMonthlySnowRunoff\n  logical (kind=c_bool) :: lFREEZING\n\n  ! [ LOCAL PARAMETERS ]\n  real (kind=c_float), parameter :: rMELT_INDEX = 1.5_c_float\n\n  ! set snowmelt to zero uniformly across model grid\n  pGrd%Cells(:,:)%rSnowMelt = rZERO\n\n  ! set snowfall to zero uniformly across model grid\n  pGrd%Cells(:,:)%rSnowFall_SWE = rZERO\n\n  ! calculate number of cells in model grid\n  iNumGridCells = pGrd%iNumGridCells\n\n  ! Use \"potential interception\" for each cell to compute net precip\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX\n      cel => pGrd%Cells(iCol,iRow)\n\n      if (pGrd%iMask(iCol, iRow) == iINACTIVE_CELL) then\n\n        dpChgInSnowCover = dpZERO\n        dpSnowCover = dpZERO\n        dpPreviousSnowCover = dpZERO\n        dpNetRainfall = dpZERO\n\n      else\n\n        ! allow for correction factor to be applied to precip gage input data\n        if ( cel%rTAvg - (cel%rTMax-cel%rTMin) / 3.0_c_float <= rFREEZING ) then\n          lFREEZING = lTRUE\n          cel%rGrossPrecip = cel%rGrossPrecip * pConfig%rSnowFall_SWE_Corr_Factor\n        else\n          lFREEZING = lFALSE\n          cel%rGrossPrecip = cel%rGrossPrecip * pConfig%rRainfall_Corr_Factor\n        end if\n\n        ! this simply retrieves the table value for the given landuse\n        dpPotentialInterception = rf_model_GetInterception(pConfig,cel)\n\n        ! save the current snowcover value, create local copy as well\n        dpPreviousSnowCover = real(cel%rSnowCover, kind=c_double)\n        dpSnowCover = real(cel%rSnowCover, kind=c_double)\n\n        ! calculate NET PRECIPITATION; assign value of zero if all of the\n        ! GROSS PRECIP is captured by the INTERCEPTION process\n        dpNetPrecip = real(cel%rGrossPrecip, kind=c_double) - dpPotentialInterception\n\n        if ( dpNetPrecip < dpZERO ) dpNetPrecip = dpZERO\n\n        dpInterception = real(cel%rGrossPrecip, kind=c_double) - dpNetPrecip\n\n        ! negative interception can only be generated if the user has supplied\n        ! *negative* values for GROSS PRECIPITATION; this has happened,\n        ! mostly due to interpolation schemes that generate pockets\n        ! of negative precip values\n        if(dpInterception < dpZERO) &\n          call Assert(lFALSE, &\n            \"Negative value for interception was calculated on day \" &\n            //int2char(iDayOfYear)//\" iRow: \"//trim(int2char(iRow)) &\n            //\"  iCol: \"//trim(int2char(iCol)), &\n            trim(__FILE__), __LINE__)\n\n        cel%rInterception = real(dpInterception, kind=c_double)\n!      cel%rInterceptionStorage = cel%rInterceptionStorage + cel%rInterception\n\n        ! NOW we're through with INTERCEPTION calculations\n        ! Next, we partition between snow and rain\n\n        ! Assume that all precipitation is rain, for now\n        dpNetRainfall = dpNetPrecip\n\n        ! Is it snowing?\n        if (lFREEZING ) then\n          dpSnowCover = dpSnowCover + dpNetPrecip\n          cel%rSnowFall_SWE = dpNetPrecip\n          dpNetRainfall = dpZERO      ! For now -- if there is snowmelt, we do it next\n        end if\n\n        ! Is there any melting?\n        if ( cel%rTAvg > rFREEZING ) then\n          dpPotentialMelt = rMELT_INDEX * ( cel%rTMax - rFREEZING ) &\n                            * dpC_PER_F / rMM_PER_INCH\n\n          if(dpSnowCover > dpPotentialMelt) then\n            cel%rSnowMelt = dpPotentialMelt\n            dpSnowCover = dpSnowCover - dpPotentialMelt\n          else   ! not enough snowcover to satisfy the amount that *could* melt\n            cel%rSnowMelt = dpSnowCover\n            dpSnowCover = dpZERO\n          end if\n\n        end if\n\n        dpChgInSnowCover = dpSnowCover - dpPreviousSnowCover\n\n        ! copy temporary double-precision values back to single-precision\n        cel%rSnowCover = real(dpSnowCover, kind=c_float)\n        cel%rNetRainfall = real(dpNetRainfall, kind=c_float)\n\n      endif\n\n      call stats_UpdateAllAccumulatorsByCell( &\n        REAL(dpChgInSnowCover,kind=c_double), iCHG_IN_SNOW_COV,iMonth,iZERO)\n\n      call stats_UpdateAllAccumulatorsByCell( &\n        dpNetRainfall,iNET_RAINFALL,iMonth,iZERO)\n\n      call stats_UpdateAllAccumulatorsByCell( &\n        REAL(cel%rSnowMelt,kind=c_double),iSNOWMELT,iMonth,iZERO)\n\n      call stats_UpdateAllAccumulatorsByCell( &\n        REAL(cel%rSnowFall_SWE,kind=c_double),iSNOWFALL_SWE,iMonth,iZERO)\n\n      call stats_UpdateAllAccumulatorsByCell( &\n        dpSnowCover,iSNOWCOVER,iMonth,iZERO)\n\n    end do\n\n  end do\n\n  ! a call to the UpdateAllAccumulatorsByCell subroutine with a value of \"iNumGridCalls\"\n  ! as the final argument triggers the routine to update monthly and annual stats\n  call stats_UpdateAllAccumulatorsByCell(dpZERO,iCHG_IN_SNOW_COV,iMonth,iNumGridCells)\n  call stats_UpdateAllAccumulatorsByCell(dpZERO,iNET_RAINFALL,iMonth,iNumGridCells)\n  call stats_UpdateAllAccumulatorsByCell(dpZERO,iSNOWMELT,iMonth,iNumGridCells)\n  call stats_UpdateAllAccumulatorsByCell(dpZERO,iSNOWFALL_SWE,iMonth,iNumGridCells)\n  call stats_UpdateAllAccumulatorsByCell(dpZERO,iSNOWCOVER,iMonth,iNumGridCells)\n\nend subroutine model_ProcessRain\n\n!----------------------------------------------------------------------\n\nsubroutine model_ProcessRainPRMS( pGrd, pConfig, iDayOfYear, iMonth, iNumDaysInYear)\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd        ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  integer (kind=c_int),intent(in) :: iDayOfYear  ! Day of the year\n  integer (kind=c_int), intent(in) :: iMonth     ! Integer month value (1-12)\n  integer (kind=c_int), intent(in) :: iNumDaysInYear\n\n  ! [ LOCALS ]\n  real (kind=c_double) :: rPotentialMelt,rPotentialInterception,rInterception\n  real (kind=c_float) :: rPreviousSnowCover,rChgInSnowCover\n  integer (kind=c_int) :: iCol,iRow\n  type (T_CELL),pointer :: cel\n  integer (kind=c_int) :: iNumGridCells\n  real (kind=c_double) :: rMin, rMean, rMax, rSum, rSum2\n  integer (kind=c_int) :: iCount\n  real (kind=c_float) ::  rMonthlySnowRunoff\n  real (kind=c_float) :: rFracRain\n  real (kind=c_float) :: rTd, rTempDifference\n  real (kind=c_double) :: rDelta,rOmega_s,rD_r, rRa, rRs, rRn_mean, rN, rRso\n  real (kind=c_float) :: rRns, rRnl, rRn, rZenithAngle\n  real (kind=c_double) :: rLatitude\n  real (kind=c_float) :: rTempComp, rRadComp\n  logical (kind=c_bool), parameter :: lENERGY_BALANCE = lFALSE\n\n  ! [ LOCAL PARAMETERS ]\n  ! from eqn 2, Kustas and Rango, 1994\n  ! value of 0.2 for A_sub_r from Brubaker et al 1996 (Snowmelt Runoff Model)\n  real (kind=c_float), parameter :: rA_sub_r = 0.2_c_float   ! cm per degree C\n  real (kind=c_float), parameter :: rM_sub_Q = 0.026_c_float  ! cm/day per W/m**2\n\n  ! Bastardized values below....\n!  real (kind=c_float), parameter :: rA_sub_r = 0.27_c_float   ! cm per degree C\n!  real (kind=c_float), parameter :: rM_sub_Q = 0.0040_c_float  ! cm/day per W/m**2\n\n  real (kind=c_float), parameter :: rAlbedoInit = 0.965   ! Kustas et al\n  real (kind=c_float), parameter :: rElevation = 1500\n  real (kind=c_float), parameter :: rMeltInitTemperature = 31.5_c_float\n\n  ! set snowmelt to zero uniformly across model grid\n!  pGrd%Cells(:,:)%rSnowMelt = rZERO\n\n  ! set snowfall to zero uniformly across model grid\n! pGrd%Cells(:,:)%rSnowFall_SWE = rZERO\n\n  ! calculate number of cells in model grid\n  iNumGridCells = pGrd%iNX * pGrd%iNY\n\n!  pGrd%Cells(:,:)%rPrevious_SnowCover = pGrd%Cells(:,:)%rSnowCover\n\n  rD_r =rel_Earth_Sun_dist(iDayOfYear,iNumDaysInYear)\n  rDelta = solar_declination(iDayOfYear, iNumDaysInYear)\n\n  do iRow=1,pGrd%iNY\n\n  rLatitude = row_latitude(pConfig%rNorthernLatitude, &\n    pConfig%rSouthernLatitude, pGrd%iNY, iRow)\n  rOmega_s = sunset_angle(rLatitude, rDelta)\n  rN = daylight_hours(rOmega_s)\n\n  ! NOTE that the following equation returns extraterrestrial radiation in\n  ! MJ / m**2 / day.\n  rRa = extraterrestrial_radiation_Ra(rLatitude,rDelta,rOmega_s,rD_r)\n  rRso = clear_sky_solar_radiation_Rso(rRa)\n  rZenithAngle = zenith_angle(rLatitude, rDelta)\n\n  ! determine the fraction of precip that falls as snow\n  do iCol=1,pGrd%iNX\n\n  cel => pGrd%Cells(iCol,iRow)\n\n  ! initialize accumulators for this cell\n  cel%rSnowMelt = rZERO\n  cel%rSnowFall_SWE = rZERO\n  cel%rSnowFall = rZERO\n\n  if(cel%rTMin > pConfig%rTMaxAllSnow &\n    .or. cel%rTMax > pConfig%rTMaxAllRain) then\n\n  rFracRain = rONE\n  cel%iDaysSinceLastSnow = cel%iDaysSinceLastSnow + 1\n\n  else if(cel%rTMax < pConfig%rTMaxAllSnow) then\n\n  rFracRain = rZERO\n  cel%iDaysSinceLastSnow = 0\n\n  else\n\n  ! this is straight from MMS/PRMS\n  rFracRain = ((cel%rTMax - pConfig%rTMaxAllSnow) &\n    / (cel%rTMax - cel%rTMin))\n  cel%iDaysSinceLastSnow = 0\n\n  end if\n\n  cel%rGrossPrecip = rFracRain * cel%rGrossPrecip * pConfig%rRainfall_Corr_Factor &\n    + (rONE - rFracRain) * cel%rGrossPrecip * pConfig%rSnowFall_SWE_Corr_Factor\n\n  rPotentialInterception = rf_model_GetInterception( pConfig, cel )\n\n  rPreviousSnowCover = cel%rSnowCover\n\n  cel%rNetPrecip = MAX(cel%rGrossPrecip-rPotentialInterception,rZERO)\n  rInterception = MAX(cel%rGrossPrecip - cel%rNetPrecip,rZERO)\n\n!      cel%rAnnualInterception = cel%rAnnualInterception + cel%rInterception\n!      rMonthlyInterception = rMonthlyInterception + cel%rInterception\n\n  cel%rSnowFall_SWE = cel%rNetPrecip * (rONE - rFracRain)\n  cel%rSnowFall = cel%rSnowFall_SWE * snow_depth_Hedstrom(cel%rTAvg, pConfig)\n  cel%rSnowCover = cel%rSnowCover + cel%rSnowFall_SWE\n  cel%rNetPrecip = cel%rNetPrecip - cel%rSnowFall_SWE\n\n  if(cel%rSnowCover > rNEAR_ZERO) then  ! no point in calculating all this\n    ! unless there is snowcover present\n\n  rRs = solar_radiation_Hargreaves_Rs(rRa, cel%rTMin, cel%rTMax) ! &\n\n  cel%rSnowAlbedo = snow_albedo(rAlbedoInit, cel%iDaysSinceLastSnow, &\n    rZenithAngle)\n\n  if(lENERGY_BALANCE) then\n\n  call snow_energy_balance(cel%rTMin, cel%rTMax, &\n    cel%rTAvg, rRs, rRso, cel%rSnowAlbedo, cel%rSnowCover, &\n    cel%rNetPrecip, cel%rSnowTemperature, cel%rSnowMelt, iCol,iRow)\n\n  else\n\n  ! amount average temperature exceeds freezing point\n  rTempDifference = FtoC(cel%rTAvg) - FtoC(rMeltInitTemperature)\n  rTd = max(rTempDifference,rZERO)\n\n  rRns = net_shortwave_radiation_Rns(rRs, real(cel%rSnowAlbedo, kind=c_double))\n\n  rRnl = net_longwave_radiation_Rnl(cel%rTMin, cel%rTMax, rRs, rRso)\n\n  rRn = rRns - rRnl\n\n  rTempComp = rA_sub_r * rTd / rCM_PER_INCH\n\n  rRadComp = max(rM_sub_Q * rRn * 11.57  / rCM_PER_INCH,rZERO)\n\n  rPotentialMelt = rTempComp + rRadComp\n#ifdef DEBUG_PRINT\n  if(iCol > 3 .and. iCol < 5 .and. iRow > 20 .and. iRow < 22) then\n    write(*,FMT=\"('Snow albedo:',t32,F14.3)\") cel%rSnowAlbedo\n    write(*,FMT=\"('Extraterrestrial radiation (Ra):',t32,F14.3)\") rRa\n    write(*,FMT=\"('Incoming shortwave (Rs):',t32,F14.3)\") rRs\n    write(*,FMT=\"('Clear sky shortwave (Rso):',t32,F14.3)\") rRso\n    write(*,FMT=\"('Zenith angle :',t32,F14.3)\") rZenithAngle\n    write(*,FMT=\"('Net shortwave (Rns):',t32,F14.3)\") rRns\n    write(*,FMT=\"('Net longwave (Rnl):',t32,F14.3)\") rRnl\n    write(*,FMT=\"('Net shortwave + longwave (Rn):',t32,F14.3)\") rRn\n    write(*,FMT=\"('Amount temp > 0 (rTd):',t32,F14.3)\") rTd\n    write(*,FMT=\"('Average temp  (rTAvg):',t32,F14.3)\") cel%rTAvg\n    write(*,FMT=\"('Temp Difference:',t32,F14.3)\") rTempDifference\n    write(*,FMT=\"('Snowcover (SWE, inches):',t32,F14.3)\") cel%rSnowCover\n    write(*,FMT=\"('Potential snowmelt (temp):',t32,F14.3)\") rTempComp\n    write(*,FMT=\"('Potential snowmelt (rad):',t32,F14.3)\") rRadComp\n    write(*,FMT=\"('Potential snowmelt:',t32,F14.3)\") rPotentialMelt\n    write(*,FMT=\"('----------------------------------------------------')\")\n  end if\n#endif\n\n  if(cel%rSnowCover > rPotentialMelt) then\n    cel%rSnowMelt = rPotentialMelt\n    cel%rSnowCover = cel%rSnowCover - rPotentialMelt\n  else\n    cel%rSnowMelt = cel%rSnowCover\n    cel%rSnowCover = rZERO\n  end if\nend if\nend if\n\n  rChgInSnowCover = cel%rSnowCover - rPreviousSnowCover\n\n  call stats_UpdateAllAccumulatorsByCell( &\n    REAL(rChgInSnowCover,kind=c_double), iCHG_IN_SNOW_COV,iMonth,iZERO)\n  call stats_UpdateAllAccumulatorsByCell( &\n    REAL(cel%rNetPrecip,kind=c_double),iNET_RAINFALL,iMonth,iZERO)\n  call stats_UpdateAllAccumulatorsByCell( &\n    REAL(cel%rSnowMelt,kind=c_double),iSNOWMELT,iMonth,iZERO)\n  call stats_UpdateAllAccumulatorsByCell( &\n    REAL(cel%rSnowFall_SWE,kind=c_double),iSNOWFALL_SWE,iMonth,iZERO)\n  call stats_UpdateAllAccumulatorsByCell( &\n    REAL(cel%rSnowCover,kind=c_double),iSNOWCOVER,iMonth,iZERO)\n\n\n  end do\n\n  end do\n\n  ! a call to the UpdateAllAccumulatorsByCell subroutine with a value of \"iNumGridCalls\"\n  ! as the final argument triggers the routine to update monthly and annual stats\n  call stats_UpdateAllAccumulatorsByCell(dpZERO,iCHG_IN_SNOW_COV,iMonth,iNumGridCells)\n!  call stats_UpdateAllAccumulatorsByCell(dpZERO,iINTERCEPTION,iMonth,iNumGridCells)\n  call stats_UpdateAllAccumulatorsByCell(dpZERO,iNET_RAINFALL,iMonth,iNumGridCells)\n  call stats_UpdateAllAccumulatorsByCell(dpZERO,iSNOWMELT,iMonth,iNumGridCells)\n  call stats_UpdateAllAccumulatorsByCell(dpZERO,iSNOWFALL_SWE,iMonth,iNumGridCells)\n  call stats_UpdateAllAccumulatorsByCell(dpZERO,iSNOWCOVER,iMonth,iNumGridCells)\n\n  return\n\nend subroutine model_ProcessRainPRMS\n\n!!***\n\n!--------------------------------------------------------------------------\n!!****s* model/model_ProcessRunoff\n! NAME\n!   model_ProcessRunoff - Calls method-specific subroutines to handle\n!                         surface runoff calculation.\n!\n! SYNOPSIS\n!   This subroutine calls the appropriate subroutine for calculating\n!   surface runoff based on whether the user has selected the iterative\n!   or downhill solution.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!   pConfig - Pointer to the model configuration data structure.\n!   iDayOfYear - Day of the current year (January 1 = 1).\n!   iMonth - Month corresponding to the current model day (January = 1).\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\n\nsubroutine model_ProcessRunoff(pGrd, pConfig, iDayOfYear, iMonth)\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd          ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  integer (kind=c_int),intent(in) :: iDayOfYear    ! day of current year (January 1 = 1)\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iCount\n  integer (kind=c_int) :: j, i\n  real (kind=c_double) :: xmin, xmax, ymin, ymax\n  integer (kind=c_int), intent(in) :: iMonth     ! Integer month value (1-12)\n  integer (kind=c_int) :: iNumGridCells\n  integer (kind=c_int), parameter :: iMAX_ITERATIONS = 200000\n  integer (kind=c_int) :: iIterationNum\n\n  ! calculate number of cells in model grid\n  iNumGridCells = pGrd%iNX * pGrd%iNY\n\n  ! Iteratively processes the runoff event; first initialize the upstream flows\n  pGrd%Cells(:,:)%rInFlow = rZERO\n  pGrd%Cells(:,:)%rOutFlow = rZERO\n  pGrd%Cells(:,:)%rFlowOutOfGrid = rZERO\n  iIterationNum = 0\n\n  if ( pConfig%iConfigureRunoffMode == CONFIG_RUNOFF_ITERATIVE ) then\n\n    do\n      iIterationNum = iIterationNum + 1\n      iCount = if_model_RunoffIteration( pGrd, pConfig, iDayOfYear, iMonth )\n      if ( iCount == 0 ) then\n        exit\n      endif\n      if (iIterationNum > iMAX_ITERATIONS) then\n        call assert(lFALSE, \"Maximum number of iterations exceeded.\", &\n        trim(__FILE__), __LINE__)\n      endif\n    end do\n\n  else if (pConfig%iConfigureRunoffMode == CONFIG_RUNOFF_DOWNHILL ) then\n\n    call model_RunoffDownhill( pGrd, pConfig, iDayOfYear, iMonth )\n\n  else if (pConfig%iConfigureRunoffMode == CONFIG_RUNOFF_NO_ROUTING ) then\n    call model_Runoff_NoRouting( pGrd, pConfig, iDayOfYear, iMonth )\n\n  else\n    call Assert(lFALSE,\"Internal error selecting a runoff routing module\" &\n      //\" runoff mode = \"//TRIM(int2char(pConfig%iConfigureRunoffMode)), &\n      TRIM(__FILE__),__LINE__)\n  end if\n\n  ! Update the moving average counter\n  iDayCtr = iDayCtr + 1\n  if ( iDayCtr > iMOVING_AVG_TERMS ) iDayCtr = 1\n\n  ! Update the inflow buffer (used to determine antecedent runoff conditions)\n  pGrd%Cells(:,:)%rNetInflowBuf(iDayCtr) = pGrd%Cells(:,:)%rNetPrecip &\n    + pGrd%Cells(:,:)%rSnowMelt + pGrd%Cells(:,:)%rInflow\n\n  return\nend subroutine model_ProcessRunoff\n\n!!***\n\n!--------------------------------------------------------------------------\n!!****s* model/model_ConfigureRunoffDownhill\n! NAME\n!   model_ConfigureRunoffDownhill - Establishes sorted list of grid cells\n!                                   (upstream-to-downstream) for use in the\n!                                   downhill solution method.\n!\n! SYNOPSIS\n!   This subroutine is only called if the user selects the downhill surface\n!   runoff solution method. This routine systematically combs the model domain\n!   looking for cells which either receive no runoff, or receive runoff from\n!   cells that are already in the downhill runoff routing table.\n!\n!   The routing table is saved in a file named 'swb_routing.bin', which\n!   is an unformatted Fortran data file.  Once this table exists, the\n!   code will take routing information from this table first before\n!   running through the process of determining a routing table from scratch.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!   pConfig - Pointer to the model configuration data structure.\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\n\nsubroutine model_ConfigureRunoffDownhill( pGrd, pConfig)\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd          ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iCol, iRow, iStat, tj, ti, iTgt_Row, iTgt_Col,k,iCumlCount,iCount\n  integer (kind=c_int) :: iRowSub, iColSub, iNChange, iUpstreamCount, iPasses\n  integer (kind=c_int) :: ic\n  integer (kind=c_int) :: iNumGridCells, iNumActiveGridCells\n  integer (kind=c_int) :: iNumIterationsNochange\n  integer (kind=c_int) :: LU_TEMP\n  logical (kind=c_bool) :: lExist\n  logical (kind=c_bool) :: lCircular = lFALSE\n  type( T_GENERAL_GRID ), pointer :: pTempGrid\n  type (T_CELL),pointer :: cel\n\n  ! calculate number of gridcells in model domain\n  iNumGridCells = pGrd%iNY * pGrd%iNX\n\n  iNumActiveGridCells = count(pGrd%iMask == iACTIVE_CELL)\n\n  ! set iteration counter\n  iNumIterationsNochange = 0\n\n  pTempGrid=>grid_Create( pGrd%iNX, pGrd%iNY, pGrd%rX0, pGrd%rY0, &\n    pGrd%rX1, pGrd%rY1, DATATYPE_INT )\n\n  allocate(iOrderCol(iNumActiveGridCells), iOrderRow(iNumActiveGridCells), stat=iStat)\n  call Assert( iStat == 0, &\n    \"Could not allocate order of solution vectors for downhill procedure\")\n\n  INQUIRE( FILE='swb_routing_table.bin', EXIST=lExist)\n\n  EXISTS: if (.not. lExist) then\n\n    iPasses = 0\n    write(UNIT=LU_LOG,FMT=*) \"Configuring the downhill routing table...\"\n    flush(UNIT=LU_LOG)\n    iOrderCount = 0\n    pGrd%Cells%lDownhillMarked = lFALSE\n\n    do\n      iNChange = 0\n      do iRow=1,pGrd%iNY\n        do iCol=1,pGrd%iNX  ! last index in a Fortan array should be the slowest changing\n          cel => pGrd%Cells(iCol,iRow)\n          if (pGrd%iMask(iCol, iRow) == iINACTIVE_CELL) cycle\n          if ( cel%lDownhillMarked ) cycle\n          ! Count upstream cells\n          iUpstreamCount = 0\n\n          cel%iSumUpslopeCells = 0\n          cel%iNumUpslopeConnections = 0\n\n          ! now search all adjacent cells which have current cell\n          ! as their target\n\n          lCircular = lFALSE\n\n          do iRowSub=iRow-1,iRow+1\n            if (iRowSub>=1 .and. iRowSub<=pGrd%iNY) then     ! we're within array bounds\n              do iColSub=iCol-1,iCol+1\n                if (iColSub>=1 .and. iColSub<=pGrd%iNX) then              ! we're within array bounds\n                  if (iRow==iRowSub .and. iCol==iColSub) cycle            ! Skip current inquiry cell\n                  if (pGrd%iMask(iColSub, iRowSub) == 0) cycle     ! Don't count inactive neighbors\n                  call model_DownstreamCell(pGrd,iRowSub,iColSub,iTgt_Row,iTgt_Col)\n\n                  if (iTgt_Row==iRow .and. iTgt_Col==iCol ) then          ! target cell points at current inquiry cell\n                    if (pGrd%Cells(iColSub,iRowSub)%lDownhillMarked) then\n\n                      cel%iSumUpslopeCells = cel%iSumUpslopeCells &\n                         + pGrd%Cells(iColSub,iRowSub)%iSumUpslopeCells + 1\n                       cel%iNumUpslopeConnections = cel%iNumUpslopeConnections + 1\n\n                    else\n\n                      iUpstreamCount = iUpstreamCount+1\n                      ! we've found a cell that points to the current model\n                      ! cell; does our current model cell point back at it?\n                      ! if so, we have circular flow\n                      call model_DownstreamCell(pGrd,iRow,iCol,iTgt_Row,iTgt_Col)\n                      if (iTgt_Row==iRowSub .and. iTgt_Col==iColSub )  lCircular = lTRUE\n\n                    endif\n\n                  end if\n                end if\n              end do\n            end if\n          end do\n\n          ! If there are none, we can mark this cell\n          ! If we have circular flow (a points to b, b points to a),\n          ! we can mark the current cell; both a and b will be set to\n          ! closed depressions in subsequent processing\n          if ( iUpstreamCount == 0  &\n            .or. (iUpstreamCount == 1 .and. lCircular)) then\n            iNChange = iNChange+1\n            cel%lDownhillMarked = lTRUE\n            iOrderCount = iOrderCount+1\n            iOrderCol(iOrderCount) = iCol\n            iOrderRow(iOrderCount) = iRow\n            !write(UNIT=LU_LOG,FMT=*) 'found ',iOrderCount, iRow, iCol\n          elseif ( iNumIterationsNochange > 10 ) then\n            ! convert offending cell into a depression\n            ! we've gotten to this point because flow paths are circular;\n            ! this is likely in a flat area of the DEM, and is in reality\n            ! likely to be a depression\n            iNChange = iNChange+1\n            cel%lDownhillMarked = lTRUE\n            cel%iFlowDir = 0\n            iOrderCount = iOrderCount+1\n            iOrderCol(iOrderCount) = iCol\n            iOrderRow(iOrderCount) = iRow\n            !write(UNIT=LU_LOG,FMT=*) 'found ',iOrderCount, iRow, iCol\n          end if\n\n        end do  ! loop over rows\n      end do  ! loop over columns\n\n      if ( iNChange==0 ) then\n\n        iNumIterationsNochange = iNumIterationsNochange + 1\n\n        iCumlCount = 0\n        write(LU_LOG,\"(/,1x,'Summary of remaining unmarked cells')\")\n\n        ! loop over possible (legal) values of the flow direction grid\n        do k=0,128\n          iCount=COUNT(.not. pGrd%Cells%lDownHillMarked &\n            .and.pGrd%Cells%iFlowDir==k .and. pGrd%iMask == 0)\n          if(iCount>0) then\n            iCumlCount = iCumlCount + iCount\n            write(LU_LOG,FMT=\"(3x,i8,' unmarked grid cells have flowdir value: ',i8)\") &\n              iCount, k\n          end if\n        end do\n\n        write(LU_LOG,FMT=\"(3x,a)\") repeat(\"-\",60)\n        write(LU_LOG,FMT=\"(3x,i8,' Total cells with nonzero flow \" &\n          //\"direction values')\") iCumlCount\n\n#ifdef DEBUG_PRINT\n\n        where( pGrd%Cells%lDownHillMarked .or.  pGrd%iMask /= 0)\n          pTempGrid%iData = iROUTE_CELL_MARKED\n        elsewhere\n          pTempGrid%iData = pGrd%Cells%iFlowDir\n        end where\n\n!        call genericgraph(pTempGrid)\n#endif\n\n        call grid_WriteArcGrid(\"iteration\"//TRIM(int2char(iPasses))// &\n          \"problem_gridcells.asc\", pTempGrid)\n\n      else\n        ! reset iteration counter\n        iNumIterationsNochange = 0\n      end if\n\n      if(iOrderCount == iNumActiveGridCells) exit\n      iPasses = iPasses+1\n      write(UNIT=LU_LOG,FMT=*) 'Iteration ',iPasses,'  ',iOrderCount,&\n        ' of ',iNumGridCells,' cells have been configured'\n\n    end do\n\n    write(UNIT=LU_LOG,FMT=*) \"  Number of passes required: \",iPasses\n    write(UNIT=LU_LOG,FMT=*) \"\"\n    flush(UNIT=LU_LOG)\n\n    open ( LU_ROUTING, FILE='swb_routing.bin',FORM='UNFORMATTED', &\n      status='REPLACE',ACCESS='STREAM')\n\n    open (unit=newunit(LU_TEMP), FILE='swb_routing_log.csv', FORM='FORMATTED', &\n      status='REPLACE')\n    write (LU_TEMP,fmt=\"(a)\") \"Row number, Col number, Num contributing cells, Num upslope connections\"\n\n    write(LU_ROUTING) iOrderCount\n    write(LU_TEMP, fmt=\"(i12)\") iOrderCount\n\n    do ic=1,iOrderCount\n      write(LU_ROUTING) iOrderCol(ic),iOrderRow(ic)\n      write(LU_TEMP, fmt=\"(i12,',',i12,',',i12,',',i12)\") iOrderRow(ic),iOrderCol(ic), &\n         pGrd%Cells(iOrderCol(ic),iOrderRow(ic))%iSumUpslopeCells, &\n         pGrd%Cells(iOrderCol(ic),iOrderRow(ic))%iNumUpslopeConnections\n    end do\n    flush(UNIT=LU_ROUTING)\n    close(UNIT=LU_ROUTING)\n    close(UNIT=LU_TEMP)\n\n    pTempGrid%iData = pGrd%Cells%iSumUpslopeCells\n\n    call make_shaded_contour(pGrd=pTempGrid, &\n      sOutputFilename=trim(pConfig%sOutputFilePrefix) // \"CALC_Upslope_Contributing_Area.png\", &\n      sTitleTxt=\"Upslope Contributing Area\", &\n      sAxisTxt=\"Number of Cells\" )\n\n    pTempGrid%iData = pGrd%Cells%iNumUpslopeConnections\n\n    call make_shaded_contour(pGrd=pTempGrid, &\n      sOutputFilename=trim(pConfig%sOutputFilePrefix) // \"CALC_Num_Upslope_Connections.png\", &\n      sTitleTxt=\"Number of Upslope Connecting Cells\", &\n      sAxisTxt=\"Number of Cells\" )\n\n  else ! routing table already exists\n\n    pGrd%Cells%lDownhillMarked = lTRUE\n    open(LU_ROUTING, FILE='swb_routing.bin',FORM='UNFORMATTED', ACCESS='STREAM')\n    read(LU_ROUTING) iOrderCount\n\n    ! crude error checking to see whether the routing table has the right\n    ! number of elements\n    call Assert(LOGICAL(iOrderCount==iNumActiveGridCells,kind=c_bool), &\n      'Problem with existing routing file.  Delete swb_routing.bin and rerun')\n\n    do ic=1,iOrderCount\n      read(LU_ROUTING) iOrderCol(ic),iOrderRow(ic)\n    end do\n\n    close(UNIT=LU_ROUTING)\n\n    write(UNIT=LU_LOG,FMT=*) \"\"\n    write(UNIT=LU_LOG,FMT=*)  \"*****************************************************************************\"\n    write(UNIT=LU_LOG,FMT=*)  \"NOTE: Read in downhill routing information from existing swb_routing.bin file\"\n    write(UNIT=LU_LOG,FMT=*)  \"*****************************************************************************\"\n    write(UNIT=LU_LOG,FMT=*) \"\"\n    flush(UNIT=LU_LOG)\n\n    write(UNIT=LU_STD_OUT,FMT=*)  \"*****************************************************************************\"\n    write(UNIT=LU_STD_OUT,FMT=*)  \"NOTE: Read in downhill routing information from existing swb_routing.bin file\"\n    write(UNIT=LU_STD_OUT,FMT=*)  \"*****************************************************************************\"\n\n  end if EXISTS\n\nend subroutine model_ConfigureRunoffDownhill\n\n!!***\n\n!--------------------------------------------------------------------------\n!!****s* model/model_RunoffDownhill\n! NAME\n!   model_RunoffDownhill - Performs a \"downhill\" one-pass solution for\n!                          the surface water runoff calculation.\n!\n! SYNOPSIS\n!   This subroutine makes a single pass through all grid cells in the\n!   model domain in order to calculate surface water runoff. The grid\n!   cells farthest upstream are solved first. Calculation of runoff amounts\n!   proceeds from upstream to downstream until a calculation has been made\n!   for all grid cells.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!   pConfig - Pointer to the model configuration data structure.\n!   iDayOfYear - Day of the current year (January 1 = 1).\n!   iMonth - Month corresponding to the current model day (January = 1).\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\n\nsubroutine model_RunoffDownhill(pGrd, pConfig, iDayOfYear, iMonth)\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd          ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  integer (kind=c_int),intent(in) :: iDayOfYear\n  integer (kind=c_int), intent(in) :: iMonth       ! Integer month value (1-12)\n  ! [ LOCALS ]\n  integer (kind=c_int) :: ic,iTgt_Col,iTgt_Row,iFrac\n  real (kind=c_float) :: rP,rR,rDelta\n  type (T_CELL),pointer :: cel\n  type (T_CELL),pointer :: target_cel\n\n  ! Reset the upstream flows (note that iOrderCount, iOrderCol, and iOrderRow are globals)\n  do ic=1,iOrderCount\n\n    cel => pGrd%Cells(iOrderCol(ic),iOrderRow(ic))\n\n    if (pGrd%iMask(iOrderCol(ic),iOrderRow(ic)) == iINACTIVE_CELL) cycle\n\n    call model_DownstreamCell(pGrd,iOrderRow(ic),iOrderCol(ic),iTgt_Row,iTgt_Col)\n\n#ifdef STREAM_INTERACTIONS\n    cel%rStreamCapture = rZERO\n#endif\n\n    ! Compute the runoff\n    cel%rOutFlow = rf_model_CellRunoff(pConfig, cel, iDayOfYear)\n\n    ! Now, route the water\n    if ( iTgt_Row == iROUTE_LEFT_GRID .or. iTgt_Col == iROUTE_LEFT_GRID ) then\n      cel%rFlowOutOfGrid = cel%rOutflow\n      cel%rOutFlow = rZERO\n      cycle\n    elseif ( iTgt_Row == iROUTE_DEPRESSION  .or. iTgt_Col == iROUTE_DEPRESSION ) then\n      ! Don't route any further; the water pools here.\n      cel%rOutFlow = rZERO\n      cycle\n    endif\n\n    ! MUST screen target values to ensure we don't start attempting\n    ! manipulation of memory that is out of bounds!!\n    call Assert(LOGICAL(iTgt_Row>0 .and. iTgt_Row <= pGrd%iNY,kind=c_bool), &\n      \"iTgt_Row out of bounds: Row = \"//int2char(iOrderRow(ic)) &\n      //\"  Col = \"//int2char(iOrderCol(ic)), &\n      trim(__FILE__),__LINE__)\n    call Assert(LOGICAL(iTgt_Col>0 .and. iTgt_Col <= pGrd%iNX,kind=c_bool), &\n      \"iTgt_Col out of bounds: Row = \"//int2char(iOrderRow(ic)) &\n      //\"  Col = \"//int2char(iOrderCol(ic)), &\n      trim(__FILE__),__LINE__)\n\n    target_cel => pGrd%Cells(iTgt_Col,iTgt_Row)\n\n    !> if target cell is inactive, assume that the water should be tracked\n    !> as flow out of grid\n    if ( pGrd%iMask(iTgt_Col,iTgt_Row) == iINACTIVE_CELL) then\n\n      cel%rFlowOutOfGrid = cel%rOutflow\n      cel%rOutFlow = rZERO\n      cycle\n\n    endif\n\n#ifdef STREAM_INTERACTIONS\n\n    if(target_cel%iStreamIndex > 0) then\n      ! route outflow to a specific stream or fracture ID\n      cel%rStreamCapture = cel%rOutFlow\n      cel%rOutFlow = rZERO\n    else if &\n#else\n    if &\n#endif\n    (target_cel%iLandUse == pConfig%iOPEN_WATER_LU &\n    .or. target_cel%rSoilWaterCap<rNEAR_ZERO) then\n      ! Don't route any further; the water has joined a generic\n      ! surface water feature. We assume that once the water hits a\n      ! surface water feature that the surface water drainage\n      ! network transports the bulk of it\n      ! out of the model domain quite rapidly\n      cel%rFlowOutOfGrid = cel%rOutflow\n      cel%rOutFlow = rZERO\n\n    else\n      ! add cell outflow to target cell inflow\n      target_cel%rInFlow = &\n        target_cel%rInFlow + cel%rOutFlow * cel%rRouteFraction\n      cel%rFlowOutOfGrid = cel%rOutflow * (rONE - cel%rRouteFraction)\n      cel%rOutflow = cel%rOutflow * cel%rRouteFraction\n    end if\n\n  end do\n\nend subroutine model_RunoffDownhill\n\n!!***\n\n!--------------------------------------------------------------------------\n!!****s* model/model_Runoff_NoRouting\n! NAME\n!   model_Runoff_NoRouting - Removes any computed runoff directly from the\n!                            model domain.\n! SYNOPSIS\n!   This subroutine makes a single pass through all grid cells in the\n!   model domain in order to calculate surface water runoff. The grid\n!   cells farthest upstream are solved first. Calculation of runoff amounts\n!   proceeds from upstream to downstream until a calculation has been made\n!   for all grid cells.\n!\n!   NOTE that this version performs *NO* routing, but simply removes any\n!   runoff directly from the model domain.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!   pConfig - Pointer to the model configuration data structure.\n!   iDayOfYear - Day of the current year (January 1 = 1).\n!   iMonth - Month corresponding to the current model day (January = 1).\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\n\nsubroutine model_Runoff_NoRouting(pGrd, pConfig, iDayOfYear, iMonth)\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd          ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  integer (kind=c_int),intent(in) :: iDayOfYear\n  integer (kind=c_int), intent(in) :: iMonth       ! Integer month value (1-12)\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iCol,iRow, iFrac\n  real (kind=c_float) :: rR\n  type (T_CELL),pointer :: cel\n  ! [ CONSTANTS ]\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX\n      cel => pGrd%Cells(iCol,iRow)\n\n  ! Compute the runoff for each cell\n  rR = rf_model_CellRunoff(pConfig, cel, iDayOfYear)\n\n  ! Now, remove any runoff from the model grid\n!      call stats_UpdateAllAccumulatorsByCell(REAL(rR,kind=c_double), &\n!         iRUNOFF_OUTSIDE,iMonth,iZERO)\n\n  cel%rFlowOutOfGrid = rR\n!       cel%rOutFlow = rR\n\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!! What is the point of this? If we aren't routing,\n!! only a small amount of water (generated from a\n!! cell directly beneath a stream segment) will\n!! be captured...\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n#ifdef STREAM_INTERACTIONS\n  ! Capture into streams or fractures\n  cel%rStreamCapture = rZERO\n  if ( cel%iStreamIndex /= 0 ) then\n    ! Compute the amount of fracture recharge\n    cel%rStreamCapture = cel%rInFlow * pconfig%rStreamMaxCapture(cel%iStreamIndex) &\n      / pconfig%rStreamMaxInflow(cel%iStreamIndex)\n    if (cel%rStreamCapture < rZERO) then\n      print *, \"Negative!\", cel%rInFlow, cel%rStreamCapture\n    endif\n    cel%rOutFlow = cel%rOutFlow - cel%rStreamCapture\n  end if\n#endif\n\n  ! we've removed the water from the grid; it shouldn't be included in\n  ! \"outflow\" water\n  cel%rOutFlow = rZERO\n\n  end do\nend do\n\n  return\n\nend subroutine model_Runoff_NoRouting\n\n!!***\n\n!--------------------------------------------------------------------------\n!!****f* model/if_model_RunoffIteration\n! NAME\n!   if_model_RunoffIteration -\n!\n!\n! SYNOPSIS\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!   pConfig - Pointer to the model configuration data structure.\n!   iDayOfYear - Day of the current year (January 1 = 1).\n!   iMonth - Month corresponding to the current model day (January = 1).\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\n\nfunction if_model_RunoffIteration(pGrd, pConfig, iDayOfYear, iMonth) result(iCount)\n  !! Performs one runoff iteration for the specified amount of precip.\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd          ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  integer (kind=c_int),intent(in) :: iDayOfYear\n  integer (kind=c_int), intent(in) :: iMonth       ! Integer month value (1-12)\n  ! [ RETURN VALUE ]\n  integer (kind=c_int) :: iCount\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iCol,iRow,iTgt_Row,iTgt_Col\n  real (kind=c_float) :: rR,rDelta\n  type (T_CELL),pointer :: cel,tcel\n  real (kind=c_double) :: xmin, xmax, ymin, ymax\n!  real (kind=c_float) :: rMonthlyRunoffOutside, rDailyRunoffOutside\n\n  ! [ CONSTANTS ]\n\n  ! reset the term for tracking outflow from one iteration to the next\n  rDelta = rZERO\n\n  ! Reset the upstream flows\n  iCount = 0\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX\n      cel => pGrd%Cells(iCol,iRow)\n\n      if (pGrd%iMask(iCol, iRow) == iINACTIVE_CELL) cycle\n\n      call model_DownstreamCell(pGrd,iRow,iCol,iTgt_Row,iTgt_Col)\n\n      if ( iTgt_Row == iROUTE_DEPRESSION ) then\n        ! Don't route any further; the water pools here.\n        cel%rOutFlow = rZERO\n        cycle\n      end if\n\n      ! Compute the runoff\n      rR = rf_model_CellRunoff(pConfig, cel, iDayOfYear)\n\n      if( iTgt_Row == iROUTE_LEFT_GRID ) then\n        rDelta = rR - cel%rFlowOutOfGrid\n        cel%rFlowOutOfGrid = cel%rFlowOutOfGrid + rDelta\n        cycle\n      end if\n\n      if ( iTgt_Row < 1 .or. iTgt_Row > pGrd%iNY ) then\n        call Assert(lFALSE, \"iTgt_Row out of bounds: iRow= \"//int2char(iRow) &\n          //\"  iCol= \"//int2char(iCol), trim(__FILE__),__LINE__)\n      endif\n\n      if ( iTgt_Col < 1 .or. iTgt_Col > pGrd%iNX ) then\n        call Assert(lFALSE, \"iTgt_Col out of bounds: iRow= \"//int2char(iRow)&\n          //\"  iCol= \"//int2char(iCol), trim(__FILE__),__LINE__)\n      endif\n\n      tcel => pGrd%Cells(iTgt_Row,iTgt_Col)\n\n      if (tcel%iLandUse == pConfig%iOPEN_WATER_LU) then\n\n        rDelta = rR - cel%rFlowOutOfGrid\n        cel%rFlowOutOfGrid = cel%rFlowOutOfGrid + rDelta\n\n      else  ! route water normally\n\n        rDelta = rR - cel%rOutFlow\n        tcel%rInFlow = tcel%rInFlow + rDelta\n        cel%rOutFlow = cel%rOutFlow + rDelta\n\n      end if\n\n      ! Did we make a change?\n      if ( rDelta > pConfig%rIterationTolerance ) then\n        iCount = iCount+1\n      end if\n\n    end do\n  end do\n\n  print *, \"Number of cells with changes in outflow: \", iCount\n\nend function if_model_RunoffIteration\n\n!!***\n\n!--------------------------------------------------------------------------\n!!****f* model/rf_model_CellRunoff\n! NAME\n!   rf_model_CellRunoff - Calculate runoff for a cell.\n!\n! SYNOPSIS\n!   This subroutine determines the runoff (outflow) from a given cell\n!   by calling the appropriate runoff calculation function. Currently the\n!   function calls either a curve-number based runoff calculation function,\n!   or a Green-Ampt based runoff calculation function (unimplemented).\n!\n! INPUTS\n!   pConfig - Pointer to the model configuration data structure.\n!   cel - Pointer to the grid cell for which runoff (outflow) calculation\n!         should occur.\n!   iDayOfYear - Integer value of the day number of the current year (1-366).\n!\n! OUTPUTS\n!   rOutFlow - Runoff (outflow) value in inches.\n!\n! SOURCE\n\nfunction rf_model_CellRunoff(pConfig, cel, iDayOfYear) result(rOutFlow)\n  !! Calculates a single cell's runoff\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  type (T_CELL),pointer :: cel\n  integer (kind=c_int),intent(in) :: iDayOfYear\n  ! [ RETURN VALUE ]\n  real (kind=c_float) :: rOutFlow\n  ! [ LOCALS ]\n\n  if (pConfig%iConfigureRunoff == CONFIG_RUNOFF_CURVE_NUMBER) then\n    rOutFlow = runoff_CellRunoff_CurveNumber(pConfig, cel, iDayOfYear)\n  else if (pConfig%iConfigureRunoff == CONFIG_RUNOFF_GREEN_AMPT) then\n    rOutFlow = rf_model_CellRunoff_GreenAmpt(pConfig, cel, iDayOfYear)\n  end if\n\n  if (rOutFlow < rZERO) then\n    call echolog(\"gross precip: \" &\n      //trim(asCharacter(cel%rGrossPrecip))//\"~outflow: \" &\n      //trim(asCharacter(rOutflow)))\n    call assert(lFALSE, \"Negative outflow calculated for cell!\", &\n      trim(__FILE__), __LINE__)\n  endif\n\nend function rf_model_CellRunoff\n\n!!***\n!--------------------------------------------------------------------------\n!!****f* model/rf_model_CellRunoff_GreenAmpt\n! NAME\n!   rf_model_CellRunoff_GreenAmpt - Calculate runoff for a cell using a\n!      Green-Ampt based calculation method.\n!\n! SYNOPSIS\n!   This function will (when implemented) return the value of runoff for\n!   the current grid cell based on a Green-Ampt based calculation method.\n!   The function currently throws an error if called.\n!\n! INPUTS\n!   pConfig - Pointer to the model configuration data structure.\n!   cel - Pointer to the grid cell for which runoff (outflow) calculation\n!         should occur.\n!   iDayOfYear - Integer value of the day number of the current year (1-366).\n!\n! OUTPUTS\n!   rOutFlow - Runoff (outflow) value in inches.\n!\n! SOURCE\n\nfunction rf_model_CellRunoff_GreenAmpt(pConfig, cel, iDayOfYear) result(rOutFlow)\n  !! Calculates a single cell's runoff using the modified Green-Ampt model\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  type (T_CELL),pointer :: cel\n  integer (kind=c_int),intent(in) :: iDayOfYear\n  ! [ RETURN VALUE ]\n  real (kind=c_float) :: rOutFlow\n  ! [ LOCALS ]\n\n  call Assert( lFALSE, \"Steve needs to put some code in here!\" )\n  !!!STEVE\n  !!!PUT SINGLE_CELL G-A _RUNOFF_ CALCULATION IN HERE\n\n  rOutFlow = -9999.\n\n  return\nend function rf_model_CellRunoff_GreenAmpt\n\n!!***\n!--------------------------------------------------------------------------\n!!****s* model/model_InitializeFlowDirection\n! NAME\n!   model_InitializeFlowDirection - Scans the flow direction grid for\n!     closed depressions and marks them.\n!\n! SYNOPSIS\n!   This subroutine makes a single pass through the FLOW DIRECTION grid\n!   input and assigns flow directions to the model grid based on that\n!   input.  If the cyclic flow routing is detected (a => b; b => a),\n!   both cells will be marked as closed depressions.  If the target of the\n!   current grid cell is outside the model domain, the target cell is\n!   identified as having left the grid.\n!\n! INPUTS\n!   pGrd - Pointer to the model grid data structure.\n!   pConfig - Pointer to the model configuration data structure.\n!\n! OUTPUTS\n!   NONE\n!\n! NOTES\n!   ** Code refers to parameters that are set within types.f95.\n!   ** Code directly modifies model grid values through the manipulation\n!       of pointers.\n!\n! SOURCE\n\nsubroutine model_InitializeFlowDirection( pGrd , pConfig)\n  !! Scans the flow direction grid for closed depressions and marks them\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd         ! pointer to model grid\n\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iRow,iCol\n  integer (kind=c_int) :: iTgt_Row,iTgt_Col\n  type (T_CELL),pointer :: cel\n  character (len=256) :: sBuf\n\n  ! [ PARAMETERS ]\n  integer (kind=c_short),parameter :: DIR_DEPRESSION=0\n  integer (kind=c_short),parameter :: DIR_RIGHT=1\n  integer (kind=c_short),parameter :: DIR_DOWN_RIGHT=2\n  integer (kind=c_short),parameter :: DIR_DOWN=4\n  integer (kind=c_short),parameter :: DIR_DOWN_LEFT=8\n  integer (kind=c_short),parameter :: DIR_LEFT=16\n  integer (kind=c_short),parameter :: DIR_UP_LEFT=32\n  integer (kind=c_short),parameter :: DIR_UP=64\n  integer (kind=c_short),parameter :: DIR_UP_RIGHT=128\n\n  ! no point in doing these calculations unless we're really going to\n  ! route water\n  if(pConfig%iConfigureRunoffMode==CONFIG_RUNOFF_NO_ROUTING) return\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX\n\n      cel => pGrd%Cells(iCol,iRow)\n\n      if (pGrd%iMask(iCol, iRow) == iINACTIVE_CELL) then\n\n       cel%iTgt_Row = iROUTE_LEFT_GRID\n       cel%iTgt_Col = iROUTE_LEFT_GRID\n       cycle\n\n     endif\n\n  select case (pGrd%Cells(iCol,iRow)%iFlowDir)\n    case ( DIR_DEPRESSION )\n      iTgt_Col = iROUTE_DEPRESSION               ! added Jan 2009 SMW\n      iTgt_Row = iROUTE_DEPRESSION               ! added Jan 2009 SMW\n      continue\n    case ( DIR_RIGHT )\n      iTgt_Row = iRow\n      iTgt_Col = iCol+1\n      if ( iTgt_Row >= 1 .and. iTgt_Row <= pGrd%iNY .and. &\n        iTgt_Col >= 1 .and. iTgt_Col <= pGrd%iNX ) then\n      if ( pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir == DIR_LEFT ) then\n        pGrd%Cells(iCol,iRow)%iFlowDir = DIR_DEPRESSION\n        pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir = DIR_DEPRESSION\n        write(UNIT=LU_LOG,FMT=*) 'depression found in cell (row, col): ',iRow,iCol\n      end if\n      end if\n    case ( DIR_DOWN_RIGHT )\n      iTgt_Row = iRow+1\n      iTgt_Col = iCol+1\n      if ( iTgt_Row >= 1 .and. iTgt_Row <= pGrd%iNY .and. &\n        iTgt_Col >= 1 .and. iTgt_Col <= pGrd%iNX ) then\n      if ( pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir == DIR_UP_LEFT ) then\n        pGrd%Cells(iCol,iRow)%iFlowDir = DIR_DEPRESSION\n        pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir = DIR_DEPRESSION\n        write(UNIT=LU_LOG,FMT=*) 'depression found in cell (row, col): ',iRow,iCol\n      end if\n      end if\n    case ( DIR_DOWN )\n      iTgt_Row = iRow+1\n      iTgt_Col = iCol\n      if ( iTgt_Row >= 1 .and. iTgt_Row <= pGrd%iNY .and. &\n        iTgt_Col >= 1 .and. iTgt_Col <= pGrd%iNX ) then\n      if ( pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir == DIR_UP ) then\n        pGrd%Cells(iCol,iRow)%iFlowDir = DIR_DEPRESSION\n        pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir = DIR_DEPRESSION\n        write(UNIT=LU_LOG,FMT=*) 'depression found in cell (row, col): ',iRow,iCol\n      end if\n      end if\n    case ( DIR_DOWN_LEFT )\n      iTgt_Row = iRow+1\n      iTgt_Col = iCol-1\n      if ( iTgt_Row >= 1 .and. iTgt_Row <= pGrd%iNY .and. &\n        iTgt_Col >= 1 .and. iTgt_Col <= pGrd%iNX ) then\n      if ( pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir == DIR_UP_RIGHT ) then\n        pGrd%Cells(iCol,iRow)%iFlowDir = DIR_DEPRESSION\n        pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir = DIR_DEPRESSION\n        write(UNIT=LU_LOG,FMT=*) 'depression found in cell (row, col): ',iRow,iCol\n      end if\n      end if\n    case ( DIR_LEFT )\n      iTgt_Row = iRow\n      iTgt_Col = iCol-1\n      if ( iTgt_Row >= 1 .and. iTgt_Row <= pGrd%iNY .and. &\n        iTgt_Col >= 1 .and. iTgt_Col <= pGrd%iNX ) then\n      if ( pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir == DIR_RIGHT) then\n        pGrd%Cells(iCol,iRow)%iFlowDir = DIR_DEPRESSION\n        pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir = DIR_DEPRESSION\n        write(UNIT=LU_LOG,FMT=*) 'depression found in cell (row, col): ',iRow,iCol\n      end if\n      end if\n    case ( DIR_UP_LEFT )\n      iTgt_Row = iRow-1\n      iTgt_Col = iCol-1\n      if ( iTgt_Row >= 1 .and. iTgt_Row <= pGrd%iNY .and. &\n        iTgt_Col >= 1 .and. iTgt_Col <= pGrd%iNX ) then\n      if ( pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir == DIR_DOWN_RIGHT) then\n        pGrd%Cells(iCol,iRow)%iFlowDir = DIR_DEPRESSION\n        pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir = DIR_DEPRESSION\n        write(UNIT=LU_LOG,FMT=*) 'depression found in cell (row, col): ',iRow,iCol\n      end if\n      end if\n    case ( DIR_UP )\n      iTgt_Row = iRow-1\n      iTgt_Col = iCol\n      if ( iTgt_Row >= 1 .and. iTgt_Row <= pGrd%iNY .and. &\n        iTgt_Col >= 1 .and. iTgt_Col <= pGrd%iNX ) then\n      if ( pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir == DIR_DOWN) then\n        pGrd%Cells(iCol,iRow)%iFlowDir = DIR_DEPRESSION\n        pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir = DIR_DEPRESSION\n        write(UNIT=LU_LOG,FMT=*) 'depression found in cell (row, col): ',iRow,iCol\n      end if\n      end if\n    case ( DIR_UP_RIGHT )\n      iTgt_Row = iRow-1\n      iTgt_Col = iCol+1\n      if ( iTgt_Row >= 1 .and. iTgt_Row <= pGrd%iNY .and. &\n        iTgt_Col >= 1 .and. iTgt_Col <= pGrd%iNX ) then\n      if ( pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir == DIR_DOWN_LEFT) then\n        pGrd%Cells(iCol,iRow)%iFlowDir = DIR_DEPRESSION\n        pGrd%Cells(iTgt_Col,iTgt_Row)%iFlowDir = DIR_DEPRESSION\n        write(UNIT=LU_LOG,FMT=*) 'depression found in cell (row, col): ',iRow,iCol\n      end if\n      end if\n    case default  !! flow direction indeterminate\n    !!\n    !!  NOTE: This may not be the correct way to deal with indeterminate\n    !!        flow directions!!\n    !!\n      write ( unit=sBuf, fmt='(\"Flow direction grid element (\",i5,\",\",i5,' &\n        // '\") contains undefined flow direction with integer value: \",i4)' ) &\n          iCol,iRow,pGrd%Cells(iCol,iRow)%iFlowDir\n      write(UNIT=LU_LOG,FMT=*)  sBuf\n      pGrd%Cells(iCol,iRow)%iFlowDir = DIR_DEPRESSION\n      iTgt_Col = iROUTE_DEPRESSION\n      iTgt_Row = iROUTE_DEPRESSION\n  end select\n\n  ! does the current value of either target point outside of the grid?\n  if ( iTgt_Row == 0 .or. iTgt_Row > pGrd%iNY .or. &\n    iTgt_Col == 0 .or. iTgt_Col > pGrd%iNX ) then\n      iTgt_Row = iROUTE_LEFT_GRID\n      iTgt_Col = iROUTE_LEFT_GRID\n  end if\n\n  ! now assign the value of the targets to the iTgt element of the\n  ! grid data structure\n  pGrd%Cells(iCol,iRow)%iTgt_Row = iTgt_Row\n  pGrd%Cells(iCol,iRow)%iTgt_Col = iTgt_Col\nend do\nend do\n\n#ifdef DEBUG_PRINT\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX\n      if(pGrd%Cells(iCol,iRow)%iTgt_Col==iCol .and. pGrd%Cells(iCol,iRow)%iTgt_Row==iRow) then\n        write(unit=LU_LOG,FMT=*) 'ALERT** target is the same as the originating cell'\n        write(unit=LU_LOG,FMT=*) '  ORIG   (iRow, iCol) : ',iRow, iCol\n        write(unit=LU_LOG,FMT=*) '  ==> FLOWDIR: ',pGrd%Cells(iCol,iRow)%iFlowDir\n        write(unit=LU_LOG,FMT=*) '  TARGET (iRow, iCol) : ',pGrd%Cells(iCol,iRow)%iTgt_Row, &\n          pGrd%Cells(iCol,iRow)%iTgt_Col\n        write(unit=LU_LOG,FMT=*) '  ==> FLOWDIR: ' , &\n          pGrd%Cells(pGrd%Cells(iCol,iRow)%iTgt_Row,pGrd%Cells(iCol,iRow)%iTgt_Col)%iFlowDir\n      end if\n    end do\nend do\n\n#endif\n\n  return\nend subroutine model_InitializeFlowDirection\n\n!!***\n\n!--------------------------------------------------------------------------\n\nsubroutine model_DownstreamCell(pGrd,iRow,iCol,iTgt_Row,iTgt_Col)\n  !! Determines the \"downstream\" cell for cell (iRow,iCol) and returns the index in\n  !! (iTgt_Row,iTgt_Col)\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd        ! pointer to model grid\n  integer (kind=c_int),intent(in) :: iRow,iCol\n  integer (kind=c_int),intent(out) :: iTgt_Row,iTgt_Col\n  ! [ PARAMETERS ]\n  integer (kind=c_short),parameter :: DIR_DEPRESSION=0\n  integer (kind=c_short),parameter :: DIR_RIGHT=1\n  integer (kind=c_short),parameter :: DIR_DOWN_RIGHT=2\n  integer (kind=c_short),parameter :: DIR_DOWN=4\n  integer (kind=c_short),parameter :: DIR_DOWN_LEFT=8\n  integer (kind=c_short),parameter :: DIR_LEFT=16\n  integer (kind=c_short),parameter :: DIR_UP_LEFT=32\n  integer (kind=c_short),parameter :: DIR_UP=64\n  integer (kind=c_short),parameter :: DIR_UP_RIGHT=128\n\n  select case (pGrd%Cells(iCol,iRow)%iFlowDir)\n    case ( DIR_DEPRESSION )\n      iTgt_Row = iROUTE_DEPRESSION  ! value is -999\n      iTgt_Col = iROUTE_DEPRESSION  ! value is -999\n    case ( DIR_RIGHT )\n      iTgt_Row = iRow\n      iTgt_Col = iCol+1\n    case ( DIR_DOWN_RIGHT )\n      iTgt_Row = iRow+1\n      iTgt_Col = iCol+1\n    case ( DIR_DOWN )\n      iTgt_Row = iRow+1\n      iTgt_Col = iCol\n    case ( DIR_DOWN_LEFT )\n      iTgt_Row = iRow+1\n      iTgt_Col = iCol-1\n    case ( DIR_LEFT )\n      iTgt_Row = iRow\n      iTgt_Col = iCol-1\n    case ( DIR_UP_LEFT )\n      iTgt_Row = iRow-1\n      iTgt_Col = iCol-1\n    case ( DIR_UP )\n      iTgt_Row = iRow-1\n      iTgt_Col = iCol\n    case ( DIR_UP_RIGHT )\n      iTgt_Row = iRow-1\n      iTgt_Col = iCol+1\n  end select\n\n  ! the following code was trapping all 'iROUTE_DEPRESSION' values and\n  ! converting them to iROUTE_LEFT_GRID values\n  !\n  ! changed test from \"iTgt_Row < 1\" to \"iTgt_Row == 0\"\n\n  if ( iTgt_Row == 0 .or. iTgt_Row > pGrd%iNY .or. &\n    iTgt_Col == 0 .or. iTgt_Col > pGrd%iNX ) then    ! Left the grid?\n  iTgt_Row = iROUTE_LEFT_GRID\n  iTgt_Col = iROUTE_LEFT_GRID\n  end if\n\n  return\nend subroutine model_DownstreamCell\n\n!--------------------------------------------------------------------------\n\nsubroutine model_ReadBasinMaskTable ( pConfig )\n  !! reads the basin cacthment data file for subsequent processing\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iStat, iNumMaskFiles, i, iRecNum, iSize\n  character (len=256) :: sRecord                  ! Input file text buffer\n  character (len=256) :: sItem                    ! Key word read from sRecord\n  character (len=256) :: sBuf\n\n  ! open basin mask file\n  open ( LU_MASK, file=pConfig%sBasinMaskFilename, &\n    status=\"OLD\", iostat=iStat )\n  call Assert( LOGICAL( iStat == 0,kind=c_bool), &\n    \"Open failed for file: \" // pConfig%sBasinMaskFilename )\n\n  ! read first line of file\n  read ( unit=LU_MASK, fmt=\"(a256)\", iostat=iStat ) sRecord\n  call Assert( iStat == 0, &\n    \"Error reading first line of basin mask table\" )\n\n  ! read mask file to obtain expected number of basin mask files\n  call chomp( sRecord, sItem, sTAB )\n  call Uppercase( sItem )\n  if ( sItem == \"NUM_BASIN_MASK_FILES\" ) then\n    call chomp( sRecord, sItem, sTAB )\n    read ( unit=sItem, fmt=*, iostat=iStat ) iNumMaskFiles\n    call Assert( iStat == 0, \"Failed to read number of basin mask files\" )\n    write(UNIT=LU_LOG,FMT=*)  \"==> allocating memory for\",iNumMaskFiles, &\n      \" landuse types within basin mask table\"\n  else\n    call Assert( lFALSE, &\n      \"Unknown option in basin mask table; was expecting NUM_BASIN_MASK_FILES #\")\n  end if\n\n  ! read (AND IGNORE) second line of file\n  read ( unit=LU_MASK, fmt=\"(a256)\", iostat=iStat ) sRecord\n  call Assert( iStat == 0, &\n    \"Error reading second line of basin mask table\" )\n\n  ! now allocate memory for BASIN MASK table\n  allocate ( pConfig%BMASK( iNumMaskFiles ), stat=iStat )\n  call Assert ( iStat == 0, &\n    \"Could not allocate space for basin mask data structure\" )\n\n  iSize = size(pConfig%BMASK,1)\n\n  iRecNum = 1\n\n  BMASK: do\n\n  read ( unit=LU_MASK, fmt=\"(a256)\", iostat=iStat ) sRecord\n  if ( iStat < 0 ) exit     ! EOF mark\n  if ( sRecord(1:1) == \"#\" ) cycle      ! Ignore comment lines\n\n  if(iRecNum > iSize) then\n    write(UNIT=LU_LOG,FMT=*) \"\"\n    write(UNIT=LU_LOG,FMT=*)  \" *** The maximum number of basin mask table elements has\"\n    write(UNIT=LU_LOG,FMT=*)  \"     been read in before reaching the end of the file.\"\n    write(UNIT=LU_LOG,FMT=*) \"\"\n    write(UNIT=LU_LOG,FMT=*)  \"     size of allocated memory for BASIN MASK table: \",iSize\n    write(UNIT=LU_LOG,FMT=*)  \"     current record number: \", iRecNum\n    exit\n  end if\n\n  write(UNIT=LU_LOG,FMT=*) \"\"\n  write(UNIT=LU_LOG,FMT=*)  \"-----------------------------------------------------------\"\n  write(UNIT=LU_LOG,FMT=*)  \"Reading basin mask record number \",iRecNum, \" of \",iNumMaskFiles\n  write(UNIT=LU_LOG,FMT=*) \"\"\n\n  call chomp( sRecord, sItem, sTAB )\n  read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%BMASK(iRecNum)%sUSGS_UpstreamOrderID\n  call Assert( iStat == 0, &\n    \"Error reading upstream order ID in basin mask table\" )\n  write(UNIT=LU_LOG,FMT=*)  \"Upstream order ID = \",TRIM(pConfig%BMASK(iRecNum)%sUSGS_UpstreamOrderID)\n\n  call chomp( sRecord, sItem, sTAB )\n  call Uppercase(sItem)\n  pConfig%BMASK(iRecNum)%sBasinDescription = TRIM(sItem)\n  call Assert( iStat == 0, &\n    \"Error reading basin description in basin mask table\" )\n  write(UNIT=LU_LOG,FMT=*)  \"Basin description = \",TRIM(pConfig%BMASK(iRecNum)%sBasinDescription)\n\n  call chomp( sRecord, sItem, sTAB )\n  pConfig%BMASK(iRecNum)%sPestGroup = TRIM(ADJUSTL(sItem))\n  call Assert( iStat == 0, &\n    \"Error reading PEST group in basin mask table\" )\n  write(UNIT=LU_LOG,FMT=*)  \"PEST group = \",TRIM(pConfig%BMASK(iRecNum)%sPestGroup)\n\n  call chomp( sRecord, sItem, sTAB )\n  read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%BMASK(iRecNum)%rPestWeight\n  call Assert( iStat == 0, &\n    \"Error reading PEST observation weight in basin mask table\" )\n  write(sBuf,FMT=\"(F12.3)\") pConfig%BMASK(iRecNum)%rPestWeight\n  write(UNIT=LU_LOG,FMT=*)  \"PEST weight = \"//TRIM(sBuf)\n\n  call chomp( sRecord, sItem, sTAB )\n!    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%BMASK(iRecNum)%sBasinMaskFilename\n  pConfig%BMASK(iRecNum)%sBasinMaskFilename = TRIM(ADJUSTL(sItem))\n  call Assert( iStat == 0, &\n    \"Error reading basin mask filename in basin mask table\" )\n  write(UNIT=LU_LOG,FMT=*)  \"Basin mask filename = \",TRIM(pConfig%BMASK(iRecNum)%sBasinMaskFilename)\n\n  call chomp( sRecord, sItem, sTAB )\n  read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%BMASK(iRecNum)%sFileType\n  call Assert( iStat == 0, &\n    \"Error reading basin mask file type in basin mask table\" )\n  write(UNIT=LU_LOG,FMT=*)  \"Basin mask filetype = \",TRIM(pConfig%BMASK(iRecNum)%sFileType)\n\n  call chomp( sRecord, sItem, sTAB )\n  read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%BMASK(iRecNum)%rQb\n  call Assert( iStat == 0, &\n    \"Error reading baseflow estimate Qb in basin mask table\" )\n  write(UNIT=LU_LOG,FMT=*)  \"Qb = \",pConfig%BMASK(iRecNum)%rQb\n\n  call chomp( sRecord, sItem, sTAB )\n  read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%BMASK(iRecNum)%rDrainageArea\n  call Assert( iStat == 0, &\n    \"Error reading basin drainage area in basin mask table\" )\n  write(UNIT=LU_LOG,FMT=*)  \"Drainage area = \", &\n    pConfig%BMASK(iRecNum)%rDrainageArea\n\n  iRecNum = iRecNum + 1\n\n  end do BMASK\n\n  flush(UNIT=LU_LOG)\n\nend subroutine model_ReadBasinMaskTable\n\n!--------------------------------------------------------------------------\n\nsubroutine model_ReadLanduseLookupTable( pConfig )\n  !! Reads the landuse data from pConfig%sLanduseLookupFilename\n  ! [ ARGUMENTS ]\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iStat, iNumLandUses, i, iType, iRecNum, iSize\n  integer (kind=c_int) :: iNumSoilTypes\n  character (len=1024) :: sRecord                  ! Input file text buffer\n  character (len=256) :: sItem                    ! Key word read from sRecord\n\n  ! open landuse file\n  open ( LU_LOOKUP, file=pConfig%sLanduseLookupFilename, &\n    status=\"OLD\", iostat=iStat )\n  call Assert( LOGICAL( iStat == 0,kind=c_bool), &\n    \"Open failed for file: \" // pConfig%sLanduseLookupFilename )\n\n  ! read first line of file\n  read ( unit=LU_LOOKUP, fmt=\"(a)\", iostat=iStat ) sRecord\n  call Assert( iStat == 0, &\n    \"Error reading first line of landuse lookup table\" )\n\n  ! read landuse file to obtain expected number of landuse types\n  call chomp(sRecord, sItem , sTAB )\n!  call chomp_tab( sRecord, sItem )\n  if ( str_compare(sItem,\"NUM_LANDUSE_TYPES\") ) then\n    call chomp(sRecord, sItem , sTAB )\n    read ( unit=sItem, fmt=*, iostat=iStat ) iNumLandUses\n    call Assert( iStat == 0, \"Failed to read number of landuse types\" )\n    write(UNIT=LU_LOG,FMT=*)  \"==> allocating memory for\",iNumLandUses,\"landuse types within lookup table\"\n  else\n    call Assert( lFALSE, &\n      \"Unknown option in landuse lookup table; was expecting NUM_LANDUSE_TYPES #\")\n  end if\n\n  !> keep track of number of landuses for use throughout code\n  pConfig%iNumberOfLanduses = iNumLandUses\n\n  ! read second line of file\n  read ( unit=LU_LOOKUP, fmt=\"(a)\", iostat=iStat ) sRecord\n  call Assert( iStat == 0, &\n    \"Error reading second line of landuse lookup table\" )\n\n  ! read landuse file to obtain expected number of soil types\n  call chomp(sRecord, sItem , sTAB )\n  call Uppercase( sItem )\n  if ( sItem == \"NUM_SOIL_TYPES\" ) then\n    call chomp(sRecord, sItem , sTAB )\n    read ( unit=sItem, fmt=*, iostat=iStat ) iNumSoilTypes\n    call Assert( iStat == 0, \"Failed to read number of soil types\" )\n    write(UNIT=LU_LOG,FMT=*)  \"==> allocating memory for\",iNumSoilTypes,\"soil types within lookup table\"\n  else\n    call Assert( lFALSE, &\n      \"Unknown option in landuse lookup table; was expecting NUM_SOIL_TYPES #\")\n  end if\n\n  pConfig%iNumberOfSoilTypes = iNumSoilTypes\n\n  ! now allocate memory for landuse table\n  allocate ( pConfig%LU( iNumLandUses ), stat=iStat )\n  call Assert ( iStat == 0, &\n    \"Could not allocate space for landuse data structure\" )\n\n  ! now allocate memory for IRRIGATION, TEW, and REW subtables\n  ! even if irrigation is not actively being used, this must be in place so that\n  ! the default growing-degree day baseline temps are available elsewhere in the code\n  allocate ( pConfig%IRRIGATION( pConfig%iNumberOfLanduses ), stat=iStat )\n  call Assert ( iStat == 0, &\n    \"Could not allocate space for IRRIGATION data structure\", trim(__FILE__), __LINE__ )\n\n  ! now allocate memory for READILY_EVAPORABLE_WATER subtable\n  allocate ( pConfig%READILY_EVAPORABLE_WATER( pConfig%iNumberOfLanduses, &\n    pConfig%iNumberOfSoilTypes), stat=iStat )\n  call Assert ( iStat == 0, &\n    \"Could not allocate space for READILY_EVAPORABLE_WATER  data structure\", &\n    trim(__FILE__), __LINE__ )\n\n   ! assign a reasonable default value\n   pConfig%READILY_EVAPORABLE_WATER = 0.3\n\n  ! now allocate memory for TOTAL_EVAPORABLE_WATER subtable\n  allocate ( pConfig%TOTAL_EVAPORABLE_WATER( pConfig%iNumberOfLanduses, &\n    pConfig%iNumberOfSoilTypes), stat=iStat )\n  call Assert ( iStat == 0, &\n    \"Could not allocate space for TOTAL_EVAPORABLE_WATER  data structure\", &\n    trim(__FILE__), __LINE__ )\n\n  ! assign another reasonable default value\n  pConfig%TOTAL_EVAPORABLE_WATER = 0.6\n\n  iSize = size(pConfig%LU,1)\n\n  ! now allocate memory for SOILS subtable within landuse table\n  allocate ( pConfig%CN( iNumLandUses,iNumSoilTypes ), stat=iStat )\n  call Assert ( iStat == 0, &\n    \"Could not allocate space for CN subtable within landuse data structure\" )\n\n  ! now allocate memory for ROOTING DEPTH subtable within landuse table\n  allocate ( pConfig%ROOTING_DEPTH( iNumLandUses,iNumSoilTypes ), stat=iStat )\n  call Assert ( iStat == 0, &\n    \"Could not allocate space for ROOTING_DEPTH subtable within landuse data structure\" )\n\n  ! now allocate memory for MAX_RECHARGE subtable within landuse table\n  allocate ( pConfig%MAX_RECHARGE( iNumLandUses,iNumSoilTypes ), stat=iStat )\n  call Assert ( iStat == 0, &\n    \"Could not allocate space for MAX_RECHARGE subtable within landuse data structure\" )\n\n  ! now allocate memory for IRRIGATION subtable within landuse table\n  ! note that this table is NOT populated in this subroutine, but in \"readIrrgationLookupTable\"\n  allocate ( pConfig%IRRIGATION( iNumLandUses ), stat=iStat )\n  call Assert ( iStat == 0, &\n    \"Could not allocate space for IRRIGATION data structure\" )\n\n  iRecNum = 1\n\n  LU_READ: do\n\n  read ( unit=LU_LOOKUP, fmt=\"(a)\", iostat=iStat ) sRecord\n  if ( iStat < 0 ) exit     ! EOF mark\n  if ( sRecord(1:1) == \"#\" ) cycle      ! Ignore comment lines\n\n  if(iRecNum > iSize) then\n    write(UNIT=LU_LOG,FMT=*) \"\"\n    write(UNIT=LU_LOG,FMT=*)  \" *** The maximum number of landuse lookup table elements has\"\n    write(UNIT=LU_LOG,FMT=*)  \"     been read in before reaching the end of the file.\"\n    write(UNIT=LU_LOG,FMT=*) \"\"\n    write(UNIT=LU_LOG,FMT=*)  \"     size of allocated memory for LU table: \",iSize\n    write(UNIT=LU_LOG,FMT=*)  \"     current record number: \", iRecNum\n    exit\n  end if\n\n  write(UNIT=LU_LOG,FMT=*) \"\"\n  write(UNIT=LU_LOG,FMT=*)  \"-----------------------------------------------------------\"\n  write(UNIT=LU_LOG,FMT=*)  \"Reading landuse record number \",iRecNum, \" of \",iNumLandUses\n  write(UNIT=LU_LOG,FMT=*) \"\"\n\n  call chomp(sRecord, sItem, sTAB)\n  read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%LU(iRecNum)%iLandUseType\n  call Assert( iStat == 0, \"Error reading land use type in landuse lookup table\" )\n  write(UNIT=LU_LOG,FMT=*)  \"  landuse type = \",pConfig%LU(iRecNum)%iLandUseType\n\n  call chomp( sRecord, pConfig%LU(iRecNum)%sLandUseDescription, sTAB)\n  write(UNIT=LU_LOG,FMT=*)  \"  landuse description = \", &\n    TRIM(pConfig%LU(iRecNum)%sLandUseDescription)\n\n  call chomp( sRecord, pConfig%LU(iRecNum)%sAssumedPercentImperviousness, sTAB)\n  write(UNIT=LU_LOG,FMT=*)  \"  assumed % imperviousness = \", &\n    TRIM(pConfig%LU(iRecNum)%sAssumedPercentImperviousness)\n\n  do i=1,iNumSoilTypes\n  call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%CN(iRecNum,i)\n    call Assert( iStat == 0, &\n      \"Error reading curve number for soil group \"//trim(int2char(i))//\" in landuse lookup table\" )\n    write(UNIT=LU_LOG,FMT=*)  \"  curve number for soil group\",i,\": \",pConfig%CN(iRecNum,i)\n  end do\n\n  do i=1,iNumSoilTypes\n  call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%MAX_RECHARGE(iRecNum,i)\n    call Assert( iStat == 0, &\n      \"Error reading maximum recharge for soil group \"//trim(int2char(i))//\" in landuse lookup table\" )\n    write(UNIT=LU_LOG,FMT=*)  \"  MAXIMUM RECHARGE for soil group\",i,\": \",pConfig%MAX_RECHARGE(iRecNum,i)\n  end do\n\n  call chomp(sRecord, sItem, sTAB)\n  read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%LU(iRecNum)%rIntercept_GrowingSeason\n  call Assert( iStat == 0, \"Error reading interception values in landuse file\" )\n  write(UNIT=LU_LOG,FMT=*)  \"  Interception value for growing season = \",pConfig%LU(iRecNum)%rIntercept_GrowingSeason\n\n  call chomp(sRecord, sItem, sTAB)\nread ( unit=sItem, fmt=*, iostat=iStat ) pConfig%LU(iRecNum)%rIntercept_NonGrowingSeason\n  call Assert( iStat == 0, \"Error reading interception values in landuse file\" )\n  write(UNIT=LU_LOG,FMT=*)  \"  Interception value for non-growing season = \", &\n    pConfig%LU(iRecNum)%rIntercept_NonGrowingSeason\n\n  ! now read in a rooting depth for each landuse/soil type combination\n  do i=1,iNumSoilTypes\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%ROOTING_DEPTH(iRecNum,i)\n    call Assert( iStat == 0, &\n      \"Error reading rooting depth for soil group \"//trim(int2char(i))//\" in landuse lookup table\" )\n    write(UNIT=LU_LOG,FMT=*)  \"  ROOTING DEPTH for soil group\",i,\": \",pConfig%ROOTING_DEPTH(iRecNum,i)\n  end do\n\n  iRecNum = iRecNum + 1\n\n  end do LU_READ\n\n  pConfig%IRRIGATION%iLandUseType = pConfig%LU%iLandUseType\n\n  ! That's all!\n  close ( unit=LU_LOOKUP )\n\n  return\nend subroutine model_ReadLanduseLookupTable\n\n!--------------------------------------------------------------------------\n\nsubroutine model_ReadIrrigationLookupTable( pConfig, pGrd )\n  !! Reads the irrigation data from pConfig%sIrrigationLookupFilename\n  ! [ ARGUMENTS ]\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  type ( T_GENERAL_GRID ),pointer :: pGrd          ! pointer to model grid\n\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iStat, iNumLandUses, i, j, iType, iRecNum, iSize\n  integer (kind=c_int) :: iLandUseType\n  integer (kind=c_int) :: iLandUseIndex\n  integer (kind=c_int) :: iNumSoilTypes\n  logical (kind=c_bool) :: lFound\n  real (kind=c_float) :: rTempValue\n  character (len=1024) :: sRecord                  ! Input file text buffer\n  character (len=256) :: sItem                    ! Key word read from sRecord\n	integer (kind=c_int) :: iCol,iRow\n  type ( T_CELL ),pointer :: cel            ! pointer to cell data structure\n\n  ! open IRRIGATION file\n  open ( LU_LOOKUP, file=pConfig%sIrrigationLookupFilename, &\n    status=\"OLD\", iostat=iStat )\n  call Assert( LOGICAL( iStat == 0,kind=c_bool), &\n    \"Open failed for file: \" // pConfig%sIrrigationLookupFilename )\n\n  call Assert(associated(pConfig%LU), \"The landuse lookup table must be read in \" &\n    //\"before the irrigation lookup table may be read.\", trim(__FILE__),__LINE__)\n\n  ! set the configuration option; if we're reading in the irrigation table,\n  ! it is assumed that the crop coefficients should be applied and\n  ! irrigation amounts calculated\n\n  iSize = size(pConfig%LU,1)\n  iNumSoilTypes = size(pConfig%CN,2)\n\n  iRecNum = 1\n\n  LU_READ: do\n\n    read ( unit=LU_LOOKUP, fmt=\"(a)\", iostat=iStat ) sRecord\n    if ( iStat < 0 ) exit     ! EOF mark\n    if ( sRecord(1:1) == \"#\" ) cycle      ! Ignore comment lines\n\n    write(UNIT=LU_LOG,FMT=*) \"\"\n    write(UNIT=LU_LOG,FMT=*)  \"-----------------------------------------------------------\"\n    write(UNIT=LU_LOG,FMT=*)  \"Reading irrigation table record number \",iRecNum\n    write(UNIT=LU_LOG,FMT=*) \"\"\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) iLandUseType\n    call Assert( iStat == 0, \"Error reading land use type in irrigation lookup table\" )\n\n    ! scan the landuse codes already supplied in the landuse lookup table and\n    ! find a match\n    lFound = lFALSE\n    do j=1,pConfig%iNumberOfLanduses\n      if(iLandUseType == pConfig%LU(j)%iLandUseType) then\n        iLandUseIndex = j\n        lFound = lTRUE\n        exit\n      endif\n    enddo\n\n    call assert(lFound, \"Unknown landuse code found while reading from the \" &\n      //\"crop coefficient and irrigation parameters table.~Landuse specified \"&\n      //\"in the irrigation table but not found in the landuse table: \" &\n      //trim(int2char(iLandUseType)),trim(__FILE__), __LINE__)\n\n    call assert(iLandUseIndex >= 1 .and. iLandUseIndex <= pConfig%iNumberOfLanduses, &\n      \"Array index out of bounds. Variable is iLandUseIndex with a value of \" &\n      //trim(int2char(iLandUseIndex)), trim(__FILE__),__LINE__)\n\n    ! store index value for future reference; allows us to easily match up\n    ! records in the landuse lookup table even if the irrigation table\n    ! is supplied in a different order\n    pConfig%IRRIGATION(iLandUseIndex)%iLandUseType = iLandUseType\n\n    call chomp(sRecord, sItem, sTAB)\n    pConfig%IRRIGATION(iLandUseIndex)%sLandUseDescription = trim(sItem)\n    write(UNIT=LU_LOG,FMT=*)  \"  landuse description \", &\n      pConfig%IRRIGATION(iLandUseIndex)%sLandUseDescription\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%IRRIGATION(iLandUseIndex)%rMeanPlantHeight\n    call Assert( iStat == 0, &\n      \"Error reading mean plant height \" &\n        //\"from irrigation lookup table\", trim(__FILE__), __LINE__ )\n    write(UNIT=LU_LOG,FMT=*)  \"  mean plant height (feet) \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rMeanPlantHeight\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%IRRIGATION(iLandUseIndex)%rKcb_ini\n    call Assert( iStat == 0, &\n      \"Error reading initial basal crop coefficient (Kcb_ini) \" &\n        //\"from irrigation lookup table\", trim(__FILE__), __LINE__ )\n    write(UNIT=LU_LOG,FMT=*)  \"  initial basal crop coefficient (Kcb_ini) \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rKcb_ini\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%IRRIGATION(iLandUseIndex)%rKcb_mid\n    call Assert( iStat == 0, &\n      \"Error reading mid-growth basal crop coefficient (Kcb_mid) \" &\n        //\"from irrigation lookup table\", trim(__FILE__), __LINE__ )\n    write(UNIT=LU_LOG,FMT=*)  \"  mid-growth basal crop coefficient (Kcb_ini) \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rKcb_mid\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%IRRIGATION(iLandUseIndex)%rKcb_end\n    call Assert( iStat == 0, &\n      \"Error reading end-growth phase basal crop coefficient (Kcb_end) \" &\n         //\"from irrigation lookup table\", trim(__FILE__), __LINE__ )\n    write(UNIT=LU_LOG,FMT=*)  \"  end-growth basal crop coefficient (Kcb_end) \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rKcb_end\n\n    pConfig%IRRIGATION(iLandUseIndex)%rKcb_max = &\n       max( pConfig%IRRIGATION(iLandUseIndex)%rKcb_ini, &\n       pConfig%IRRIGATION(iLandUseIndex)%rKcb_mid, &\n       pConfig%IRRIGATION(iLandUseIndex)%rKcb_end )\n\n    write(UNIT=LU_LOG,FMT=*)  \"  maximum basal crop coefficient (Kcb_max) \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rKcb_max\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%IRRIGATION(iLandUseIndex)%rKcb_min\n    call Assert( iStat == 0, &\n      \"Error reading minimum allowable crop coefficient (Kcb_min) \" &\n         //\"from irrigation lookup table\", trim(__FILE__), __LINE__ )\n    write(UNIT=LU_LOG,FMT=*)  \"  end-growth basal crop coefficient (Kcb_min) \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rKcb_min\n      ! initialize rKcb to the minimum value\n      pConfig%IRRIGATION(iLandUseIndex)%rKcb = pConfig%IRRIGATION(iLandUseIndex)%rKcb_min\n\n!    call chomp(sRecord, sItem, sTAB)\n!    pConfig%IRRIGATION(iLandUseIndex)%iBeginIrrigation = mmddyyyy2doy(sItem)\n!    write(UNIT=LU_LOG,FMT=*)  \"   irrigation starts on or after day \", &\n!      pConfig%IRRIGATION(iLandUseIndex)%iBeginIrrigation\n\n    call chomp(sRecord, sItem, sTAB)\n      if ( scan(sItem, \"/\") /= 0 ) then\n        pConfig%IRRIGATION(iLandUseIndex)%iL_plant = mmdd2doy(sItem)\n      else\n        read ( unit=sItem, fmt=*, iostat=iStat ) rTempValue\n        call Assert( iStat == 0, &\n          \"Error reading day of year (or GDD) of initial planting from \" &\n            //\"irrigation lookup table\" , trim(__FILE__), __LINE__ )\n        pConfig%IRRIGATION(iLandUseIndex)%iL_plant = int(rTempValue)\n      endif\n    write(UNIT=LU_LOG,FMT=*)  \"  day of year (or GDD) of initial planting \", &\n      pConfig%IRRIGATION(iLandUseIndex)%iL_plant\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) rTempValue\n    call Assert( iStat == 0, &\n      \"Error reading number of days (or GDD) until end of initial plant growth \" &\n        //\"phase from irrigation lookup table\" , trim(__FILE__), __LINE__ )\n    pConfig%IRRIGATION(iLandUseIndex)%iL_ini = int(rTempValue) &\n		  + pConfig%IRRIGATION(iLandUseIndex)%iL_plant\n    write(UNIT=LU_LOG,FMT=*)  \"  length (in days or GDD) until end of \" &\n	    //\"initial plant growth phase \", int(rTempValue)\n    write(UNIT=LU_LOG,FMT=*)  \"  day of year (or GDD) for end of \" &\n      //\"initial plant growth phase \", pConfig%IRRIGATION(iLandUseIndex)%iL_ini\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) rTempValue\n    call Assert( iStat == 0, &\n      \"Error reading length (days or GDD) until end of plant development \" &\n        //\"phase from irrigation lookup table\" , trim(__FILE__), __LINE__ )\n    pConfig%IRRIGATION(iLandUseIndex)%iL_dev = int(rTempValue) &\n				  + pConfig%IRRIGATION(iLandUseIndex)%iL_ini\n    write(UNIT=LU_LOG,FMT=*)  \"  length (in days or GDD) until end of \" &\n	    //\"plant development phase \", int(rTempValue)\n    write(UNIT=LU_LOG,FMT=*)  \"  day of year (or GDD) for end of \" &\n      //\"plant development \", pConfig%IRRIGATION(iLandUseIndex)%iL_dev\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) rTempValue\n    call Assert( iStat == 0, &\n      \"Error reading length (days or GDD) until end of mid-season growth \" &\n        //\"phase from irrigation lookup table\" , trim(__FILE__), __LINE__ )\n    pConfig%IRRIGATION(iLandUseIndex)%iL_mid = int(rTempValue) &\n		      + pConfig%IRRIGATION(iLandUseIndex)%iL_dev\n    write(UNIT=LU_LOG,FMT=*)  \"  length (in days or GDD) until end of \" &\n	    //\"mid-season growth phase \", int(rTempValue)\n    write(UNIT=LU_LOG,FMT=*)  \"  day of year (or GDD) for end of \" &\n      //\"mid-season growth phase \", pConfig%IRRIGATION(iLandUseIndex)%iL_mid\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) rTempValue\n    call Assert( iStat == 0, &\n      \"Error reading length (days or GDD) until end of late-season growth \" &\n        //\"phase from irrigation lookup table\" , trim(__FILE__), __LINE__ )\n    pConfig%IRRIGATION(iLandUseIndex)%iL_late = int(rTempValue) &\n		      + pConfig%IRRIGATION(iLandUseIndex)%iL_mid\n    write(UNIT=LU_LOG,FMT=*)  \"  length (in days or GDD) until end of \" &\n	    //\"late-season growth phase \", int(rTempValue)\n    write(UNIT=LU_LOG,FMT=*)  \"  day of year (or GDD) for end of \" &\n      //\"late-season growth phase \", pConfig%IRRIGATION(iLandUseIndex)%iL_late\n\n    call chomp(sRecord, sItem, sTAB)\n    if(str_compare(sItem,\"GDD\") ) then\n      pConfig%IRRIGATION(iLandUseIndex)%lUnitsAreDOY = lFALSE\n    elseif(str_compare(sItem,\"DOY\") ) then\n      pConfig%IRRIGATION(iLandUseIndex)%lUnitsAreDOY = lTRUE\n    else\n      call Assert( lFALSE, &\n      \"Error reading units label from irrigation lookup table.~ Valid\" &\n        //\" entries are 'GDD' or 'DOY'\", trim(__FILE__), __LINE__ )\n    endif\n    write(UNIT=LU_LOG,FMT=*)  \"  growth targets given in units of \", &\n      dquote(sItem)\n\n    do i=1,iNumSoilTypes\n      call chomp(sRecord, sItem, sTAB)\n      ! READILY_EVAPORABLE_WATER(# LU, #Soil Types)\n      read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%READILY_EVAPORABLE_WATER(iLandUseIndex,i)\n      call Assert( iStat == 0, &\n        \"Error reading readily evaporable water for soil group \" &\n          //trim(int2char(i))//\" and landuse \" &\n          //trim(int2char(pConfig%IRRIGATION(iLandUseIndex)%iLandUseType) ) &\n          //\" in landuse lookup table\" , trim(__FILE__), __LINE__ )\n      write(UNIT=LU_LOG,FMT=*)  \"  readily evaporable water for soil group\",i,\": \", &\n        pConfig%READILY_EVAPORABLE_WATER(iLandUseIndex,i)\n    end do\n\n    do i=1,iNumSoilTypes\n      call chomp(sRecord, sItem, sTAB)\n      ! TOTAL_EVAPORABLE_WATER(# LU, #Soil Types)\n      read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%TOTAL_EVAPORABLE_WATER(iLandUseIndex,i)\n      call Assert( iStat == 0, &\n        \"Error reading total evaporable water for soil group \" &\n          //trim(int2char(i))//\" and landuse \" &\n          //trim(int2char(pConfig%IRRIGATION(iLandUseIndex)%iLandUseType) ) &\n          //\" in landuse lookup table\" , trim(__FILE__), __LINE__ )\n      write(UNIT=LU_LOG,FMT=*)  \"  total evaporable water for soil group\",i,\": \", &\n        pConfig%TOTAL_EVAPORABLE_WATER(iLandUseIndex,i)\n    end do\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%IRRIGATION(iLandUseIndex)%rDepletionFraction\n    call Assert( iStat == 0, &\n      \"Error reading plant stress depletion fraction in irrigation lookup table\" )\n    write(UNIT=LU_LOG,FMT=*)  \"   plant stress depletion fraction: \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rDepletionFraction\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%IRRIGATION(iLandUseIndex)%rGDD_BaseTemp\n    call Assert( iStat == 0, &\n      \"Error reading GDD base temperature in irrigation lookup table\" )\n    write(UNIT=LU_LOG,FMT=*)  \"   GDD base temperature \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rGDD_BaseTemp\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%IRRIGATION(iLandUseIndex)%rGDD_MaxTemp\n    call Assert( iStat == 0, &\n      \"Error reading GDD max temperature in irrigation lookup table\" )\n    write(UNIT=LU_LOG,FMT=*)  \"   GDD max temperature \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rGDD_MaxTemp\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) pConfig%IRRIGATION(iLandUseIndex)%rMAD\n    call Assert( iStat == 0, &\n      \"Error reading management allowable deficit (MAD) in irrigation lookup table\" )\n    write(UNIT=LU_LOG,FMT=*)  \"   management allowable deficit (MAD) \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rMAD\n\n    call chomp(sRecord, sItem, sTAB)\n    pConfig%IRRIGATION(iLandUseIndex)%iBeginIrrigation = mmdd2doy(sItem)\n    write(UNIT=LU_LOG,FMT=*)  \"   irrigation starts on or after day \", &\n      pConfig%IRRIGATION(iLandUseIndex)%iBeginIrrigation\n\n    call chomp(sRecord, sItem, sTAB)\n    pConfig%IRRIGATION(iLandUseIndex)%iEndIrrigation = mmdd2doy(sItem)\n    write(UNIT=LU_LOG,FMT=*)  \"   irrigation ends on day \", &\n      pConfig%IRRIGATION(iLandUseIndex)%iEndIrrigation\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) &\n      pConfig%IRRIGATION(iLandUseIndex)%rFractionOfIrrigationFromGW\n    call Assert( iStat == 0, &\n      \"Error reading the fraction of irrigation water obtained from groundwater \" &\n      //\"from the irrigation lookup table\" )\n    write(UNIT=LU_LOG,FMT=*)  \"  fraction of irrigation water obtained from groundwater \", &\n      pConfig%IRRIGATION(iLandUseIndex)%rFractionOfIrrigationFromGW\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) rTempValue\n    call Assert( iStat == 0, &\n      \"Error reading the fraction of irrigation water obtained from groundwater \" &\n      //\"from the irrigation lookup table\" )\n    call assert(rTempValue > 0., &\n      \"Fractional irrigation efficiency for groundwater sources must be greater than 0.\", &\n      trim(__FILE__),__LINE__)\n    write(UNIT=LU_LOG,FMT=*)  \"  fractional irrigation efficiency for groundwater sources \", &\n      rTempValue\n    pConfig%IRRIGATION(iLandUseIndex)%rIrrigationEfficiency_GW = 1.0 / rTempValue\n\n    call chomp(sRecord, sItem, sTAB)\n    read ( unit=sItem, fmt=*, iostat=iStat ) rTempValue\n    call Assert( iStat == 0, &\n      \"Error reading the fraction of irrigation water obtained from surface water \" &\n      //\"from the irrigation lookup table\" )\n    call assert(rTempValue > 0., &\n      \"Fractional irrigation efficiency for surface-water sources must be greater than 0.\", &\n      trim(__FILE__),__LINE__)\n    write(UNIT=LU_LOG,FMT=*)  \"  fractional irrigation efficiency for surface-water sources \", &\n      rTempValue\n    pConfig%IRRIGATION(iLandUseIndex)%rIrrigationEfficiency_SW = 1.0 / rTempValue\n\n    iRecNum = iRecNum + 1\n\n  end do LU_READ\n\n  ! That's all!\n  close ( unit=LU_LOOKUP )\n\nend subroutine model_ReadIrrigationLookupTable\n\n!--------------------------------------------------------------------------\n\nfunction rf_model_GetInterception( pConfig, cel ) result(rIntRate)\n  !! Looks up the interception value for land-use type iType.\n\n  ! [ ARGUMENTS ]\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  type (T_CELL),pointer :: cel\n\n  ! [ RETURN VALUE ]\n  real (kind=c_float) :: rIntRate\n\n  ! [ LOCALS ]\n  integer ( kind=c_int ) :: i\n  type ( T_LANDUSE_LOOKUP ),pointer :: pLU\n\n  pLU => pConfig%LU(cel%iLandUseIndex)\n\n  ! Default is zero\n  rIntRate = rZERO\n  if ( cel%lGrowingSeason ) then\n    rIntRate = pLU%rIntercept_GrowingSeason\n  else\n    rIntRate = pLU%rIntercept_NonGrowingSeason\n  end if\n\n  if (rIntRate < rZero) then\n\n    call echolog(\"Negative interception value encountered. Check your lookup tables.\" &\n      //\"~landuse code: \"//trim(asCharacter(pLU%iLanduseType)) &\n      //\"~landuse description: \"//trim(pLU%sLanduseDescription) )\n\n    call Assert(lFALSE, \"\")\n  endif\n\nend function rf_model_GetInterception\n\n!--------------------------------------------------------------------------\n\nsubroutine model_CheckConfigurationSettings( pGrd, pConfig )\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd               ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig      ! pointer to data structure that contains\n\n\n  call assert(DAT(FLOWDIR_DATA)%iSourceDataType /= DATATYPE_NA, &\n    \"No flow direction information has been specified. If you are not\" &\n    //\"~routing flow, add a directive such as 'FLOW_DIRECTION CONSTANT 1'\" &\n    //\" to your ~control file.\" )\n\n  call assert(DAT(LANDUSE_DATA)%iSourceDataType /= DATATYPE_NA, &\n    \"No landuse data has been specified. If you have only\" &\n    //\"~a single landuse type, add a directive such as 'LANDUSE CONSTANT 21'\" &\n    //\"~to your control file.\" )\n\n  call assert(DAT(AWC_DATA)%iSourceDataType /= DATATYPE_NA, &\n    \"No available water capacity grid has been specified. If you do not presently\" &\n    //\"~have an AWC grid, you may add a directive such as 'WATER_CAPACITY CONSTANT 2.6'\" &\n    //\"~to your control file in order to run SWB.\" )\n\n  call assert(DAT(SOILS_GROUP_DATA)%iSourceDataType /= DATATYPE_NA, &\n    \"No hydrologic soils group grid has been specified. If you do not presently\" &\n    //\"~have an HSG grid, you may add a directive such as 'HYDROLOGIC_SOIL_GROUP CONSTANT 1'\" &\n    //\"~to your control file in order to run SWB.\" )\n\n  if (pConfig%lEnableIrrigation .and. pConfig%iConfigureFAO56 == CONFIG_FAO56_NONE ) then\n    call assert( lFALSE, \"The irrigation module must be used with one of the FAO-56 crop~\" &\n      //\"coefficient submodels enabled. These can be enabled by adding one of the following~\" &\n      //\"to your control file:~\"//sTAB//\"~\" &\n      //sTAB//\"FAO56 CROP_COEFFICIENTS_ONE_FACTOR_STANDARD~\" &\n      //sTAB//\"FAO56 CROP_COEFFICIENTS_TWO_FACTOR_STANDARD~\" &\n      //sTAB//\"FAO56 CROP_COEFFICIENTS_ONE_FACTOR_NONSTANDARD~\" &\n      //sTAB//\"FAO56 CROP_COEFFICIENTS_TWO_FACTOR_NONSTANDARD~\")\n  endif\n\nend subroutine model_CheckConfigurationSettings\n\n!--------------------------------------------------------------------------\n\nsubroutine model_setInactiveCells( pGrd, pConfig )\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd               ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig      ! pointer to data structure that contains\n\n  where ( pGrd%Cells%iSoilGroup < 0 .or. &\n          pGrd%Cells%iFlowDir < 0 .or. &\n          pGrd%Cells%iLandUse < 0)\n\n    pGrd%iMask = iINACTIVE_CELL\n\n  endwhere\n\n  call echolog(\"Finished converting cells with missing data to inactive cells.\" &\n    //\"~ A total of \"//trim(asCharacter(count(pGrd%iMask==iINACTIVE_CELL))) &\n    //\" cells were inactivated out of \"//trim(asCharacter(pConfig%iNumGridCells))//\" cells.\")\n\nend subroutine model_setInactiveCells\n\n!--------------------------------------------------------------------------\n\nsubroutine model_InitializeDataStructures( pGrd, pConfig )\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd               ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig      ! pointer to data structure that contains\n\n  call DAT(FLOWDIR_DATA)%getvalues( pGrdBase=pGrd)\n  pGrd%Cells%iFlowDir = pGrd%iData\n\n  pGenericGrd_int%iData = pGrd%Cells%iFlowDir\n\n  where(pGenericGrd_int%iData< 0)\n    pGenericGrd_int%iMask = iINACTIVE_CELL\n  elsewhere\n    pGenericGrd_int%iMask = iACTIVE_CELL\n  endwhere\n\n  call grid_WriteGrid(sFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Flow_Direction_Grid\" // &\n    \".\"//trim(pConfig%sOutputFileSuffix), pGrd=pGenericGrd_int, iOutputFormat=pConfig%iOutputFormat )\n\n  call make_shaded_contour(pGrd=pGenericGrd_int, &\n     sOutputFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Flow_Direction_Grid.png\", &\n     sTitleTxt=\"D8 Flow Direction Grid\", &\n     sAxisTxt=\"Flow Direction\" )\n\n  call DAT(SOILS_GROUP_DATA)%getvalues( pGrdBase=pGrd)\n  pGrd%Cells%iSoilGroup = pGrd%iData\n\n  where(pGenericGrd_int%iData< 0)\n    pGenericGrd_int%iMask = iINACTIVE_CELL\n  elsewhere\n    pGenericGrd_int%iMask = iACTIVE_CELL\n  endwhere\n\n  pGenericGrd_int%iData = pGrd%Cells%iSoilGroup\n  call grid_WriteGrid(sFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Hydrologic_Soils_Group\" // &\n    \".\"//trim(pConfig%sOutputFileSuffix), pGrd=pGenericGrd_int, iOutputFormat=pConfig%iOutputFormat )\n\n  call make_shaded_contour(pGrd=pGenericGrd_int, &\n      sOutputFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Hydrologic_Soils_Group.png\", &\n      sTitleTxt=\"Hydrologic Soils Group\", &\n      sAxisTxt=\"HSG\" )\n\n  call DAT(AWC_DATA)%getvalues( pGrdBase=pGrd)\n  pGrd%Cells%rSoilWaterCapInput = pGrd%rData\n\n  write(LU_LOG, fmt=\"(a, f14.3)\") \"  Minimum AWC: \", minval(pGrd%Cells%rSoilWaterCapInput)\n  write(LU_LOG, fmt=\"(a, f14.3)\") \"  Maximum AWC: \", maxval(pGrd%Cells%rSoilWaterCapInput)\n\n  pGenericGrd_sgl%rData = pGrd%Cells%rSoilWaterCapInput\n\n  where(pGenericGrd_sgl%rData< 0)\n    pGenericGrd_sgl%iMask = iINACTIVE_CELL\n  elsewhere\n    pGenericGrd_sgl%iMask = iACTIVE_CELL\n  endwhere\n\n  call grid_WriteGrid(sFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Available_Water_Capacity\" // &\n    \".\"//trim(pConfig%sOutputFileSuffix), pGrd=pGenericGrd_sgl, iOutputFormat=pConfig%iOutputFormat )\n\n  call make_shaded_contour(pGrd=pGenericGrd_sgl, &\n     sOutputFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Available_Water_Capacity.png\", &\n     sTitleTxt=\"Available Water Capacity\", &\n     sAxisTxt=\"AWC (inches per foot)\" )\n\n  if (DAT(ROUTING_FRAC_DATA)%iSourceDataType /= DATATYPE_NA) then\n\n    call DAT(ROUTING_FRAC_DATA)%getvalues( pGrdBase=pGrd)\n    pGrd%Cells%rRouteFraction = pGrd%rData\n\n    write(LU_LOG, fmt=\"(a, f14.3)\") \"  Minimum routing fraction: \", minval(pGrd%Cells%rRouteFraction)\n    write(LU_LOG, fmt=\"(a, f14.3)\") \"  Maximum routing fraction: \", maxval(pGrd%Cells%rRouteFraction)\n\n    pGenericGrd_sgl%rData = pGrd%Cells%rRouteFraction\n\n    where(pGenericGrd_sgl%rData< 0)\n      pGenericGrd_sgl%iMask = iINACTIVE_CELL\n    elsewhere\n      pGenericGrd_sgl%iMask = iACTIVE_CELL\n    endwhere\n\n    call grid_WriteGrid(sFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Routing_Fraction\" // &\n      \".\"//trim(pConfig%sOutputFileSuffix), pGrd=pGenericGrd_sgl, iOutputFormat=pConfig%iOutputFormat )\n\n    call make_shaded_contour(pGrd=pGenericGrd_sgl, &\n       sOutputFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Routing_Fraction.png\", &\n       sTitleTxt=\"Routing Fraction\", &\n       sAxisTxt=\"Routing Fraction (unitless)\" )\n\n  endif\n\n  if (DAT(MASK_DATA)%iSourceDataType /= DATATYPE_NA) then\n\n    call DAT(MASK_DATA)%getvalues( pGrdBase=pGrd)\n\n    where ( pGrd%iData > 0 )\n      pGrd%iMask = iACTIVE_CELL\n    elsewhere\n      pGrd%iMask = iINACTIVE_CELL\n    endwhere\n\n    pGenericGrd_int%iData = pGrd%iData\n    call grid_WriteGrid(sFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Basin_Mask\" // &\n      \".\"//trim(pConfig%sOutputFileSuffix), pGrd=pGenericGrd_int, iOutputFormat=pConfig%iOutputFormat )\n\n    call make_shaded_contour(pGrd=pGenericGrd_int, &\n       sOutputFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Basin_mask.png\", &\n       sTitleTxt=\"Input Basin Mask\", &\n       sAxisTxt=\"Basin Mask (unitless)\" )\n\n  endif\n\n!  call DAT(LANDUSE_DATA)%getvalues( pGrdBase=pGrd )\n!  pGrd%Cells%iLandUse = pGrd%iData\n!  pGenericGrd_int%iData = pGrd%Cells%iLandUse\n\n!  print *, trim(__FILE__), __LINE__\n!  call grid_WriteGrid(sFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Landuse_Landcover\" // &\n!    \".\"//trim(pConfig%sOutputFileSuffix), pGrd=pGenericGrd_int, iOutputFormat=pConfig%iOutputFormat )\n\n!  call make_shaded_contour(pGrd=pGenericGrd_int, &\n!     sOutputFilename=trim(pConfig%sOutputFilePrefix) // \"INPUT_Flow_Landuse_Landcover.png\", &\n!     sTitleTxt=\"Landuse / Landcover\", &\n!     sAxisTxt=\"LULC Code\" )\n\nend subroutine model_InitializeDataStructures\n\n!--------------------------------------------------------------------------\n\nsubroutine model_InitializeInputAndOutput( pGrd, pConfig )\n\n    ! [ ARGUMENTS ]\n    type ( T_GENERAL_GRID ),pointer :: pGrd               ! pointer to model grid\n    type (T_MODEL_CONFIGURATION), pointer :: pConfig      ! pointer to data structure that contains\n\n   ! [ LOCALS ]\n   integer (kind=c_int) :: iStat\n\n  call stats_OpenBinaryFiles(pConfig, pGrd)\n\n  call stats_InitializeVolumeConversion(pGrd)\n\n#ifdef DEBUG_PRINT\n  call grid_WriteArcGrid(\"SSF_Grid_Cells.\"//trim(pConfig%sOutputFileSuffix), &\n    pGrd%rX0, pGrd%rX1,pGrd%rY0,pGrd%rY1,REAL(pGrd%Cells(:,:)%iNumFilesSSF) )\n#endif\n\n  ! open file into which daily summaries of variables will be written\n  if ( pConfig%lReportDaily ) call stats_OpenMSBReport()\n\n  ! open CSV file for daily stats summary\n  if ( pConfig%lReportDaily ) then\n    open(LU_CSV_MIN, file='SWB_daily_MINIMUM_values.csv',iostat=iStat,&\n      status='REPLACE')\n    open(LU_CSV_MEAN, file='SWB_daily_MEAN_values.csv',iostat=iStat,&\n      status='REPLACE')\n    open(LU_CSV_MAX, file='SWB_daily_MAXIMUM_values.csv',iostat=iStat,&\n      status='REPLACE')\n\n    call Assert(iStat == 0, &\n      \"Problem opening CSV files for summary statistics output.\")\n\n    call stats_WriteDailyAccumulatorHeaderCSV(LU_CSV_MIN,iMIN)\n    call stats_WriteDailyAccumulatorHeaderCSV(LU_CSV_MEAN,iMEAN)\n    call stats_WriteDailyAccumulatorHeaderCSV(LU_CSV_MAX,iMAX)\n  end if\n\n  ! open CSV file for annual stats summary\n  open(LU_CSV_ANNUAL, file='SWB_annual_statistics.csv',iostat=iStat,&\n    status='REPLACE')\n  call Assert(iStat == 0, &\n    \"Problem opening CSV file for summary annual statistics output.\")\n  call stats_WriteAnnualAccumulatorHeaderCSV(LU_CSV_ANNUAL)\n\nend subroutine model_InitializeInputAndOutput\n\n!----------------------------------------------------------------------\n\nsubroutine model_InitializeRunoff( pGrd, pConfig )\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd               ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig      ! pointer to data structure that contains\n\n\n  ! If we are routing water, we *must* call InitializeFlowDirection\n  if( pConfig%iConfigureRunoffMode /= CONFIG_RUNOFF_NO_ROUTING) then\n    write(UNIT=LU_LOG,FMT=*)  \"model.F90: model_InitializeFlowDirection\"\n    call model_InitializeFlowDirection( pGrd , pConfig)\n  end if\n\n  ! Are we solving using the downhill algorithm?\n  if ( pConfig%iConfigureRunoffMode == CONFIG_RUNOFF_DOWNHILL ) then\n    ! if a routing table exists, read it in; else initialize and\n    ! save the routing table for future use\n    write(UNIT=LU_LOG,FMT=*)  \"model.F90: model_ConfigureRunoffDownhill\"\n    call model_ConfigureRunoffDownhill( pGrd, pConfig)\n  end if\n\nend subroutine model_InitializeRunoff\n\n!----------------------------------------------------------------------\n\nsubroutine model_InitializeLanduseRelatedParams( pGrd, pConfig )\n\n  type ( T_GENERAL_GRID ),pointer :: pGrd          ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n\n  write(UNIT=LU_LOG,FMT=*)  \"model.F90: model_CreateLanduseIndex\"\n  flush(unit=LU_LOG)\n  call model_CreateLanduseIndex(pGrd, pConfig )\n\n  write(UNIT=LU_LOG,FMT=*) \"model.F90: calling model_InitializeSM\"\n  flush(unit=LU_LOG)\n  call model_InitializeSM(pGrd, pConfig)\n\n  write(UNIT=LU_LOG,FMT=*)  \"model.F90: runoff_InitializeCurveNumber\"\n  flush(unit=LU_LOG)\n  call runoff_InitializeCurveNumber( pGrd ,pConfig)\n\nend subroutine model_InitializeLanduseRelatedParams\n\n!--------------------------------------------------------------------------\n\nsubroutine model_InitializeET( pGrd, pConfig )\n  !! Depending on the ET model in use, initializes the values for ET\n  !! calculations.\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd          ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n\n\n  write(UNIT=LU_LOG,FMT=*)  \"model_InitializeET : \"\n  write(UNIT=LU_LOG,FMT=*)  \"  filename = \", TRIM(pConfig%sTimeSeriesFilename)\n\n  select case ( pConfig%iConfigureET )\n    case ( CONFIG_ET_NONE )\n      call Assert( .false._c_bool, \"No ET configuration was specified\" )\n    case ( CONFIG_ET_THORNTHWAITE_MATHER )\n      call et_tm_initialize ( pGrd, pConfig, pConfig%sTimeSeriesFilename)\n    case ( CONFIG_ET_TURC )\n      call et_turc_initialize ( pGrd, pConfig%sTimeSeriesFilename)\n    case ( CONFIG_ET_JENSEN_HAISE )\n      call et_jh_initialize ( pGrd, pConfig%sTimeSeriesFilename)\n    case ( CONFIG_ET_BLANEY_CRIDDLE )\n      call et_bc_initialize ( pGrd, pConfig%sTimeSeriesFilename)\n    case ( CONFIG_ET_HARGREAVES )\n\n  end select\n\nend subroutine model_InitializeET\n\n!--------------------------------------------------------------------------\n\nsubroutine model_ProcessET( pGrd, pConfig, iDayOfYear, iNumDaysInYear, &\n  rRH, rMinRH, rWindSpd, rSunPct )\n!! Depending on the ET model in use, computes the potential ET for each\n!! cell, based on the meteorological data given. Stores cell-by-cell PET\n!! values in the model grid.\n!!\n! [ ARGUMENTS ]\ntype ( T_GENERAL_GRID ),pointer :: pGrd          ! pointer to model grid\ntype (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n  ! model options, flags, and other settings\ninteger (kind=c_int),intent(in) :: iDayOfYear, iNumDaysInYear\nreal (kind=c_float),intent(in) :: rRH,rMinRH,rWindSpd,rSunPct\n\n  ! [ LOCALS ]\n  type (T_CELL),pointer :: cel                      ! pointer to a particular cell\n  integer (kind=c_int) :: iCol, iRow\n  type (T_IRRIGATION_LOOKUP),pointer :: pIRRIGATION  ! pointer to an irrigation table entry\n\n  select case ( pConfig%iConfigureET )\n    case ( CONFIG_ET_NONE )\n      call Assert( .false._c_bool, \"No ET configuration was specified\" )\n    case ( CONFIG_ET_THORNTHWAITE_MATHER )\n      call et_tm_ComputeET ( pGrd, pConfig, iDayOfYear )\n    case ( CONFIG_ET_TURC )\n      call et_turc_ComputeET ( pGrd, iDayOfYear, rRH, rSunPct)\n    case ( CONFIG_ET_JENSEN_HAISE )\n      call et_jh_ComputeET ( pGrd, iDayOfYear, rRH, rMinRH, &\n        rWindSpd, rSunPct)\n    case ( CONFIG_ET_BLANEY_CRIDDLE )\n      call et_bc_ComputeET ( pGrd, iDayOfYear, rRH, rMinRH, &\n        rWindSpd, rSunPct)\n    case ( CONFIG_ET_HARGREAVES )\n      call et_hargreaves_ComputeET ( pGrd, pConfig, iDayOfYear, iNumDaysInYear)\n  end select\n\n\n! if the ground is still frozen, we're not going to consider ET to be\n! possible.\n!where (pGrd%Cells%rCFGI > rNEAR_ZERO)\n!  pGrd%Cells%rReferenceET0 = rZERO\n!endwhere\n\n! in order to integrate Thornthwaite-Mather approach with FAO56 approach,\n! an adjusted reference ET0 is now defined... must populate this\npGrd%Cells%rReferenceET0_adj = pGrd%Cells%rReferenceET0\n\nend subroutine model_ProcessET\n\n!--------------------------------------------------------------------------\n\nsubroutine model_InitializeSM(pGrd, pConfig )\n  !! Depending on the SM model in use, computes the change in soil moisture\n  !! and also the recharge (if any) for each cell in the grid, given the\n  !! precipitation rPrecip and the snow melt rSnowMelt\n  !!\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd         ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iCol,iRow,k\n  type ( T_CELL ),pointer :: cel            ! pointer to cell data structure\n  type ( T_LANDUSE_LOOKUP ),pointer :: pLU  ! pointer to landuse data structure\n  logical ( kind=c_bool ) :: lMatch\n\n  ! [ LOCAL PARAMETERS ]\n\n  if(pConfig%iConfigureSMCapacity==CONFIG_SM_CAPACITY_CALCULATE) then\n    ! Update the soil-water capacity based on land-cover and soil type\n    do iRow=1,pGrd%iNY\n      do iCol=1,pGrd%iNX\n\n        lMatch = lFALSE\n        cel => pGrd%Cells(iCol,iRow)\n\n        if (pGrd%iMask(iCol, iRow) == iINACTIVE_CELL) cycle\n\n        ! loop over all LAND use types...\n        do k=1,size(pConfig%LU,1)\n          pLU => pConfig%LU(k)\n          if ( pLU%iLandUseType == cel%iLandUse ) then\n\n            !> must guard against segfaulting due to illegal values of\n            !> soil type\n            if (cel%iSoilGroup > uBound(pConfig%ROOTING_DEPTH,2) &\n                 .or. cel%iSoilGroup < lBound(pConfig%ROOTING_DEPTH,2) ) then\n\n              call assert(lFALSE, &\n                 \"Soil group value is out of bounds: \" &\n                 //\"col: \"//trim(asCharacter(iCol)) &\n                 //\"  row: \"//trim(asCharacter(iRow)) &\n                 //\"  value: \"//trim(asCharacter(cel%iSoilGroup)), &\n                 trim(__FILE__), __LINE__)\n            endif\n\n            cel%rSoilWaterCap = cel%rSoilWaterCapInput * &\n               pConfig%ROOTING_DEPTH(k,cel%iSoilGroup)\n            lMatch=lTRUE\n            exit\n          end if\n        end do\n\n        if(.not. lMATCH) then\n          call Assert(lFALSE,&\n            \"Failed to match landuse grid with landuse table during soil moisture initialization~\" &\n            //\" Row: \"//trim(int2char(iRow))//\"  Col: \"//trim(int2char(iCol)) &\n            //\"  cell LU: \"//trim(int2char(int(cel%iLandUse, kind=c_int) ) ) )\n        endif\n      end do\n    end do\n  end if\n\n  select case ( pConfig%iConfigureSM )\n\n    case ( CONFIG_SM_NONE )\n      call Assert( lFALSE, \"No soil moisture calculation method was specified\" )\n    case ( CONFIG_SM_TM_LOOKUP_TABLE )\n      call sm_thornthwaite_mather_Initialize ( pGrd, pConfig )\n    case ( CONFIG_SM_TM_EQUATIONS )\n      call sm_thornthwaite_mather_Initialize ( pGrd, pConfig )\n    case default\n\n  end select\n\nend subroutine model_InitializeSM\n\n!--------------------------------------------------------------------------\n\nsubroutine model_CreateLanduseIndex(pGrd, pConfig )\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd         ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iCol,iRow,k\n  type ( T_CELL ),pointer :: cel            ! pointer to cell data structure\n\n  type ( T_LANDUSE_LOOKUP ),pointer :: pLU  ! pointer to landuse data structure\n  logical ( kind=c_bool ) :: lMatch\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX\n      lMatch = lFALSE\n      cel => pGrd%Cells(iCol,iRow)\n\n      if ( pGrd%iMask(iCol, iRow) == iINACTIVE_CELL ) cycle\n\n      do k=1,size(pConfig%LU,1)\n        pLU => pConfig%LU(k)\n        if ( pLU%iLandUseType == cel%iLandUse ) then\n          ! save index of matching landuse for ease of processing land use properties later\n          cel%iLandUseIndex = k\n !         ! need to ensure that the soil type doesn't exceed\n !         ! the max number of soil types or we get a core dump\n          call Assert(cel%iSoilGroup <= size(pConfig%MAX_RECHARGE,2), &\n             \"Value in soil type grid exceeds the maximum \" &\n             // \"number of soil types in the land use lookup table.\", &\n             trim(__FILE__),__LINE__)\n !         cel%rMaxRecharge = pConfig%MAX_RECHARGE(k,INT(cel%iSoilGroup,kind=c_int))\n          lMatch=lTRUE\n          exit\n        end if\n      end do\n      if(.not. lMATCH) then\n        call echolog (\"iRow: \"//trim(asCharacter(iRow))//\"  iCol: \"//trim(asCharacter(iCol)) &\n          //\"  cell LU: \"//trim(asCharacter( cel%iLandUse )) )\n        call Assert(lFALSE,&\n          \"Failed to match landuse grid with landuse table during creation of landuse indices\", &\n          trim(__FILE__),__LINE__)\n      endif\n    end do\n  end do\n\nend subroutine model_CreateLanduseIndex\n\n!--------------------------------------------------------------------------------------------\n\nsubroutine model_CreateIrrigationTableIndex(pGrd, pConfig )\n\n  ! [ ARGUMENTS ]\n  type ( T_GENERAL_GRID ),pointer :: pGrd         ! pointer to model grid\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n    ! model options, flags, and other settings\n  ! [ LOCALS ]\n  integer (kind=c_int) :: iCol,iRow,j\n  type ( T_CELL ),pointer :: cel            ! pointer to cell data structure\n  logical ( kind=c_bool ) :: lMatch\n\n  do iRow=1,pGrd%iNY\n    do iCol=1,pGrd%iNX\n\n      cel => pGrd%Cells(iCol,iRow)\n\n      lMatch = lFALSE\n      do j=1,size(pConfig%IRRIGATION,1)\n        if(cel%iLanduse == pConfig%IRRIGATION(j)%iLandUseType) then\n          cel%iIrrigationTableIndex = j\n          lMatch = lTRUE\n          exit\n        endif\n      enddo\n\n      call assert(lMatch, \"Unknown landuse code found while reading from the \" &\n        //\"crop coefficient and irrigation parameters table.~Landuse specified \"&\n        //\"in the landuse grid but not found in the irrigation table.~ \" &\n        //\"  Landuse grid value: \"//trim(int2char(cel%iLanduse)),trim(__FILE__), __LINE__)\n\n		enddo\n	enddo\n\nend subroutine model_CreateIrrigationTableIndex\n\n!--------------------------------------------------------------------------\n\nsubroutine model_WriteGrids(pGrd, pConfig, iOutputType)\n!! Writes the monthly output arrays in the proper grid format\n! [ ARGUMENTS ]\ntype ( T_GENERAL_GRID ),pointer :: pGrd        ! pointer to model grid\ntype (T_MODEL_CONFIGURATION), pointer :: pConfig ! pointer to data structure that contains\n  ! model options, flags, and other settings\ninteger (kind=c_int), intent(in) :: iOutputType\n\n  ! [ LOCALS ]\n  real (kind=c_double) :: xmin,xmax,ymin,ymax\n  character (len=256) sBufOut,sBufFuture,sBufSuffix,sDayText,sMonthText, &\n    sYearText, sDateText\n\n  sBufOut = trim(pConfig%sOutputFilePath)//trim(pConfig%sOutputFilePrefix) &\n       //trim( YEAR_INFO(pConfig%iMonth)%sName )\n  sBufFuture = trim(pConfig%sFutureFilePath)//trim(pConfig%sFutureFilePrefix)\n  sBufSuffix = trim(pConfig%sOutputFileSuffix)\n\n  write(sDateText,fmt=\"(i4,'/',i2.2,'/',i2.2)\") pConfig%iYear,pConfig%iMonth,pConfig%iDay\n  write(sDayText,fmt=\"(a1,i2.2,a1,i2.2,a1,i4)\") \"_\",pConfig%iMonth,\"_\",pConfig%iDay,\"_\",pConfig%iYear\n  write(sMonthText,fmt=\"(a1,i2.2,a1,i4)\") \"_\",pConfig%iMonth,\"_\",pConfig%iYear\n  write(sYearText,fmt=\"(a1,i4)\") \"_\",pConfig%iYear\n\n  xmin = pGrd%rX0\n  xmax = pGrd%rX1\n  ymin = pGrd%rY0\n  ymax = pGrd%rY1\n\n   if(MAXVAL(pGrd%Cells%rMSB) > 0.1 .or. MINVAL(pGrd%Cells%rMSB) < -0.1) then\n\n     pGenericGrd_sgl%rData = pGrd%Cells%rMSB\n     call grid_WriteGrid( &\n       sFilename=\"MASS_BALANCE\"//trim(sDayText)//\".\"//trim(sBufSuffix), &\n       pGrd=pGenericGrd_sgl, iOutputFormat=pConfig%iOutputFormat)\n     call make_shaded_contour(pGrd=pGenericGrd_sgl, &\n           sOutputFilename=\"MASS_BALANCE\"//trim(sDayText)//\".png\", &\n           sTitleTxt=\"MASS BALANCE ERROR AMOUNTS: \"//trim(sDateText), &\n           sAxisTxt=\"INCHES\" )\n\n\n   elseif ( iOutputType == WRITE_ASCII_GRID_ANNUAL ) then\n\n     pGenericGrd_sgl%rData = pGrd%Cells%rSoilMoisturePct\n     call grid_WriteGrid(sFilename=trim(sBufFuture) // \"final_pct_sm\" // &\n     trim(sYearText) // \".\" //trim(sBufSuffix), &\n       pGrd=pGenericGrd_sgl, iOutputFormat=pConfig%iOutputFormat)\n\n     pGenericGrd_sgl%rData = pGrd%Cells%rSnowCover\n     call grid_WriteGrid(sFilename=trim(sBufFuture) // \"final_snow_cover\" // &\n       trim(sYearText) // \".\" //trim(sBufSuffix), &\n       pGrd=pGenericGrd_sgl, iOutputFormat=pConfig%iOutputFormat )\n\n   elseif ( iOutputType == WRITE_ASCII_GRID_DAILY ) then\n\n   elseif ( iOutputType == WRITE_ASCII_GRID_MONTHLY ) then\n\n   elseif ( iOutputType == WRITE_ASCII_GRID_DIAGNOSTIC ) then\n\n   elseif ( iOutputType == WRITE_ASCII_GRID_DEBUG ) then\n\n   end if\n\nend subroutine model_WriteGrids\n\n!> This subroutine reads a single line from a single-station\n!> climate data file, parses the values, and returns a pointer to a\n!> time-series data object.\n!> @todo Make logic at end of routine more robust; currently the logic\n!> to test for the presence of a header could mask errors reading in\n!> values from the data file.\nsubroutine model_ReadTimeSeriesFile(pConfig, pTS)\n\n  type (T_MODEL_CONFIGURATION), pointer :: pConfig      ! pointer to data structure that contains\n  type (T_TIME_SERIES_FILE), pointer :: pTS\n\n  ! [ LOCALS ]\n  character(len=256) :: sBuf\n  integer (kind=c_int) :: iStat\n  real (kind=c_float) :: rMaxRH\n\n  do\n\n    ! read line from the time series file\n    read ( unit=LU_TS, fmt=\"(a256)\", iostat=iStat ) sBuf\n\n    ! check for end-of-file condition\n    if ( is_iostat_end(iStat) ) then\n      pTS%lEOF = lTRUE\n      ! if we have enabled STRICT_DATE_CHECKING, terminate the run\n\n#ifdef STRICT_DATE_CHECKING\n      if(.not. (pConfig%iMonth == 12 .and. pConfig%iDay == 31)) then\n        write(unit=LU_LOG,FMT=*) \"Time series file ends prematurely:\"\n        write(unit=LU_LOG,FMT=*) \"  file = \"//TRIM(pConfig%sTimeSeriesFilename)\n        write(unit=sBuf,FMT=*) \"Time series file ends prematurely: \" &\n           //TRIM(pConfig%sTimeSeriesFilename)\n        call Assert(lFALSE,TRIM(sBuf),TRIM(__FILE__),__LINE__)\n      end if\n#endif\n\n      exit ! END OF FILE; exit main do loop\n    end if\n\n    ! check for errors\n    call Assert ( iStat == 0, \"Problems reading time series file: \" &\n           //TRIM(pConfig%sTimeSeriesFilename), TRIM(__FILE__),__LINE__)\n\n    ! Ignore comment statements and blank lines\n    if ( sBuf(1:1) == '#' ) cycle\n    if (len_trim(sBuf) == 0 ) cycle\n\n    ! eliminate punctuation\n    call CleanUpCsv ( sBuf )\n    read ( unit=sBuf, fmt=*, iostat=iStat ) pTS%iMonth, pTS%iDay, &\n      pTS%iYear, pTS%rAvgT, pTS%rPrecip, pTS%rRH, pTS%rMaxT, pTS%rMinT, &\n      pTS%rWindSpd, pTS%rMinRH, pTS%rSunPct\n    if (iStat /= 0) then  ! this is a sloppy way of getting past the header\n      write(UNIT=LU_LOG,FMT=*) \"Skipping: \",trim(sBuf)\n      write(UNIT=LU_LOG,FMT=*)\n      cycle\n    end if\n\n    if(pTS%rMaxT< -100 .or. pTS%rMinT < -100 .or. pTS%rMaxT < pTS%rMinT &\n      .or. pTS%rPrecip < 0.) then\n      call echolog( \"Missing or corrupt data in climate file. ~\" &\n        //\"Input: \"//TRIM(sBuf))\n      call Assert(lFALSE, \"\",TRIM(__FILE__),__LINE__)\n    end if\n\n    if(.not. pConfig%lHaltIfMissingClimateData) then\n      if(pTS%rMinRH < 0.0 .or. pTS%rMinRH > 100.0) then\n        pTS%rMinRH = minimum_rel_hum(pTS%rMinT, pTS%rMaxT)\n      endif\n\n      if(pTS%rRH < 0.0 .or. pTS%rRH > 100.0) then\n        rMaxRH = maximum_rel_hum(pTS%rMinT)\n        pTS%rRH = ( rMaxRH + pTS%rMinRH ) / 2_c_float\n      endif\n\n     if(pTS%rSunPct < 0.0 .or. pTS%rSunPct > 100.0) then\n        pTS%rSunPct = estimate_percent_of_possible_sunshine(pTS%rMaxT, pTS%rMinT)\n     endif\n\n     if(pTS%rWindSpd < 0.0 .or. pTS%rWindSpd > 50.) then\n       pTS%rWindSpd = 2_c_float\n     endif\n\n    endif\n\n    ! Check to ensure that we have not skipped a day\n    ! we have to ignore the very first day because when running while using\n    ! a single-site file, the pConfig values are populated with the\n    ! values read from the time series file. Thus, this test will always\n    ! be true on the first day of the simulation when reading from a\n    ! single-site file.\n\n    if (.not. pConfig%lFirstDayOfSimulation) then\n\n      if(.not. ( (pConfig%iYear == pTS%iYear) &\n         .and.   (pConfig%iMonth == pTS%iMonth) &\n         .and.   (pConfig%iDay == pTS%iDay) ) ) then\n        write(unit=LU_LOG,FMT=*) \"Missing or out-of-order data in time-series file:\"\n        write(unit=LU_STD_OUT,FMT=*) \"Missing or out-of-order data in time-series file\"\n        write(unit=LU_LOG,FMT=*) \"  date (TS file)= \"//TRIM(int2char(pTS%iMonth))//\"/\" &\n          //TRIM(int2char(pTS%iDay))//\"/\" &\n          //TRIM(int2char(pTS%iYear))\n        write(unit=LU_LOG,FMT=*) \"  date (SWB)= \"//TRIM(int2char(pConfig%iMonth))//\"/\" &\n          //TRIM(int2char(pConfig%iDay))//\"/\" &\n          //TRIM(int2char(pConfig%iYear))\n#ifdef STRICT_DATE_CHECKING\n        call Assert(lFALSE,\"\",TRIM(__FILE__),__LINE__)\n#else\n        ! reset date to that of the input time-series data\n        pConfig%iYear = pTS%iYear\n        pConfig%iMonth = pTS%iMonth\n        pConfig%iDay = pTS%iDay\n        pConfig%iCurrentJulianDay = julian_day ( pConfig%iYear, pConfig%iMonth, pConfig%iDay )\n#endif\n      endif\n\n    endif\n\n    exit\n\n  end do\n\nend subroutine model_ReadTimeSeriesFile\n\nend module model\n",
			"file": "/Users/smwesten/SMWData/Source_Code/swb/src/model.F90",
			"file_size": 148970,
			"file_write_time": 130335091420000000,
			"settings":
			{
				"buffer_size": 145121,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "!> @file\n!> This module provides a layer of abstraction between the\n!> SWB data structures and the source of the data being accessed. The idea is that\n!> when SWB requests updated grid values, this is the module that requests data\n!> from the appropriate source, whether that is an ARC ASCII grid or NetCDF, etc.\n!> @ingroup data\n\n!> @namespace data_factory\n!>  Provide a uniform way from within the main SWB code to access data,\n!> for example, call mydata%getvalues(), which will retrieve data from the\n!> appropriate underlying source, whether that is a series of ARC ASCII grids,\n!> a single NetCDF file, or a series of NetCDF files.\nmodule data_factory\n\n  use types\n\n  use swb_grid\n\n  use netcdf4_support\n  use iso_c_binding\n  implicit none\n  private\n\n  integer (kind=c_int), parameter :: NETCDF_FILE_OPEN = 27\n  integer (kind=c_int), parameter :: NETCDF_FILE_CLOSED = 42\n\n  public :: NETCDF_FILE_OPEN, NETCDF_FILE_CLOSED\n\n  !> @class T_DATA_GRID\n  type, public :: T_DATA_GRID\n    integer (kind=c_int) :: iSourceDataForm    ! constant, static grid, dynamic grid\n    integer (kind=c_int) :: iSourceDataType = DATATYPE_NA  ! real, short, integer, etc.\n    integer (kind=c_int) :: iSourceFileType  ! Arc ASCII, Surfer, NetCDF\n    integer (kind=c_int) :: iTargetDataType = DATATYPE_NA  ! Fortran real, integer, etc.\n    character (len=256) :: sDescription = \"\"\n    character (len=256) :: sSourcePROJ4_string\n    character (len=256) :: sSourceFileType\n    character (len=256) :: sFilenameTemplate    ! e.g. %Y_%#_prcp.nc\n    character (len=256) :: sSourceFilename      ! e.g. 1980_00_prcp.nc\n    character (len=256) :: sOldFilename = \"NA\"  ! e.g. 1980_00_prcp.nc\n    integer (kind=c_int) :: iFileCount = -1\n    integer (kind=c_int) :: iFileCountYear = -9999\n    logical (kind=c_bool) :: lProjectionDiffersFromBase = lFALSE\n    real (kind=c_float) :: rMinAllowedValue = -rBIGVAL     ! default condition is to impose\n    real (kind=c_float) :: rMaxAllowedValue = rBIGVAL      ! no bounds on data\n    integer (kind=c_int) :: iMinAllowedValue = -iBIGVAL     ! default condition is to impose\n    integer (kind=c_int) :: iMaxAllowedValue = iBIGVAL      ! no bounds on data\n    real (kind=c_float) :: rMissingValuesCode = -rBIGVAL\n    integer (kind=c_int) :: iMissingValuesCode = -iBIGVAL\n    character (len=2) :: sMissingValuesOperator = \"<=\"\n    integer (kind=c_int) :: iMissingValuesAction = 0\n    real (kind=c_double) :: rScaleFactor = 1_c_double\n    real (kind=c_double) :: rAddOffset = 0_c_double\n    real (kind=c_double) :: rConversionFactor = 1_c_double\n\n    logical (kind=c_bool) :: lUserSuppliedScaleAndOffset = lFALSE\n    logical (kind=c_bool) :: lApplyConversionFactor = lFALSE\n    logical (kind=c_bool) :: lMissingFilesAreAllowed = lFALSE\n    logical (kind=c_bool) :: lFlipHorizontal = lFALSE\n    logical (kind=c_bool) :: lFlipVertical = lFALSE\n\n    integer (kind=c_int) :: iDaysToPadAtYearsEnd = 0\n    integer (kind=c_int) :: iDaysToPadIfLeapYear = 1\n    integer (kind=c_int) :: iStartYear = -9999\n    integer (kind=c_int) :: iEndYear = -9999\n    logical (kind=c_bool) :: lPadReplaceWithZero = lFALSE\n    logical (kind=c_bool) :: lPadValues = lFALSE\n\n    ! the following are only used if data are being read from a NetCDF file\n    character (len=256) :: sVariableName_x = \"x\"\n    character (len=256) :: sVariableName_y = \"y\"\n    character (len=256) :: sVariableName_z = \"\"\n    character (len=256) :: sVariableName_time = \"time\"\n    character (len=3) :: sVariableOrder = \"tyx\"\n\n    type (T_GRID_BOUNDS) :: GRID_BOUNDS\n    ! units?\n    ! conversion factor?\n\n    integer (kind=c_int) :: iNC_FILE_STATUS = NETCDF_FILE_CLOSED\n    type (T_NETCDF4_FILE) :: NCFILE\n\n    integer (kind=c_int) :: iNC_ARCHIVE_STATUS = NETCDF_FILE_CLOSED\n    type (T_NETCDF4_FILE) :: NCFILE_ARCHIVE\n    integer (kind=c_size_t) :: iNCFILE_RECNUM = 0\n\n    integer (kind=c_int) :: iConstantValue\n    real (kind=c_float) :: rConstantValue\n\n    ! pGrdNative is a grid created to serve as an intermediary between\n    ! the native coordinate of the data source file and the project coordinates\n    ! in use by swb\n    type (T_GENERAL_GRID), pointer :: pGrdNative => NULL()\n    logical (kind=c_bool) :: lGridIsPersistent = lFALSE\n    logical (kind=c_bool) :: lGridHasChanged = lFALSE\n    logical (kind=c_bool) :: lPerformFullInitialization = lTRUE\n    logical (kind=c_bool) :: lCreateLocalNetCDFArchive = lFALSE\n\n  contains\n\n    procedure :: init_const_int => initialize_constant_int_data_object_sub\n    procedure :: init_const_real => initialize_constant_real_data_object_sub\n    procedure :: init_gridded => initialize_gridded_data_object_sub\n\n    procedure :: initialize_netcdf => initialize_netcdf_data_object_sub\n\n    generic :: initialize => init_const_int, &\n                             init_const_real, &\n                             init_gridded\n\n    procedure :: set_scale => set_scale_sub\n    procedure :: set_offset => set_offset_sub\n\n    procedure :: set_minimum_allowable_value_int_sub\n    procedure :: set_minimum_allowable_value_real_sub\n    procedure :: set_maximum_allowable_value_int_sub\n    procedure :: set_maximum_allowable_value_real_sub\n    generic :: set_valid_minimum => set_minimum_allowable_value_int_sub, &\n                                    set_minimum_allowable_value_real_sub\n    generic :: set_valid_maximum => set_maximum_allowable_value_int_sub, &\n                                    set_maximum_allowable_value_real_sub\n\n    procedure :: set_grid_flip_horizontal => set_grid_flip_horizontal_sub\n    procedure :: set_grid_flip_vertical => set_grid_flip_vertical_sub\n    procedure :: set_conversion_factor => set_conversion_factor_sub\n\n    procedure :: getvalues_constant => getvalues_constant_sub\n    procedure :: getvalues_gridded => getvalues_gridded_sub\n\n    procedure :: getvalues_netcdf => getvalues_dynamic_netcdf_sub\n\n    procedure :: getvalues => getvalues_sub\n\n !   procedure :: update => update_data_object_sub\n !   procedure :: destroy => create_data_object_sub\n    procedure :: get_filetype => get_source_filetype_fn\n\n    procedure :: set_filecount => set_filecount\n    procedure :: reset_filecount => reset_filecount\n    procedure :: reset_at_yearend_filecount => reset_at_yearend_filecount\n    procedure :: increment_filecount => increment_filecount\n\n    procedure :: set_const_int => set_constant_value_int\n    procedure :: set_const_real => set_constant_value_real\n    generic :: set_constant => set_const_int, set_const_real\n\n    procedure :: make_filename => make_filename_from_template\n    procedure :: set_PROJ4 => set_PROJ4_string_sub\n    procedure :: set_variable_order => set_variable_order_sub\n    procedure :: dump_data_structure => dump_data_structure_sub\n    procedure :: set_make_local_archive => set_archive_local_sub\n    procedure :: put_values_to_archive => put_values_to_local_NetCDF_sub\n    procedure :: transfer_from_native => transform_grid_to_grid\n\n    procedure :: enforce_limits_real => data_GridEnforceLimits_real\n    procedure :: enforce_limits_int => data_GridEnforceLimits_int\n    generic :: enforce_limits => enforce_limits_real, enforce_limits_int\n\n    procedure :: handle_missing_values_real => data_GridHandleMissingData_real\n    procedure :: handle_missing_values_int => data_GridHandleMissingData_int\n    generic :: handle_missing_values => handle_missing_values_real, &\n                                        handle_missing_values_int\n\n    procedure :: calc_project_boundaries => calc_project_boundaries\n    procedure :: test_for_need_to_pad_values => test_for_need_to_pad_values\n\n  end type T_DATA_GRID\n\n  type (T_DATA_GRID), dimension(12), public, target :: DAT\n\n  integer (kind=c_int), parameter, public :: LANDUSE_DATA = 1\n  integer (kind=c_int), parameter, public :: AWC_DATA = 2\n  integer (kind=c_int), parameter, public :: SOILS_GROUP_DATA = 3\n  integer (kind=c_int), parameter, public :: FLOWDIR_DATA = 4\n  integer (kind=c_int), parameter, public :: ROUTING_FRAC_DATA = 5\n  integer (kind=c_int), parameter, public :: PRECIP_DATA = 6\n  integer (kind=c_int), parameter, public :: TMIN_DATA = 7\n  integer (kind=c_int), parameter, public :: TMAX_DATA = 8\n  integer (kind=c_int), parameter, public :: REL_HUM_DATA = 9\n  integer (kind=c_int), parameter, public :: SOL_RAD_DATA = 10\n  integer (kind=c_int), parameter, public :: WIND_VEL_DATA = 11\n  integer (kind=c_int), parameter, public :: MASK_DATA = 12\n\n  integer (kind=c_int), parameter, public :: MISSING_VALUES_ZERO_OUT = 0\n  integer (kind=c_int), parameter, public :: MISSING_VALUES_REPLACE_WITH_MEAN = 1\n\ncontains\n\n  subroutine initialize_constant_real_data_object_sub( &\n     this, &\n     sDescription, &\n     rConstant )\n\n     class (T_DATA_GRID) :: this\n     character (len=*) :: sDescription\n     real (kind=c_float), intent(in) :: rConstant\n\n     this%rConstantValue = rConstant\n     this%sDescription = trim(sDescription)\n     this%iSourceDataForm = CONSTANT_GRID\n     this%iSourceDataType = DATATYPE_REAL\n     this%iTargetDataType = DATATYPE_REAL\n     this%iSourceFileType = FILETYPE_NONE\n\n    call netcdf_nullify_data_struct( NCFILE=this%NCFILE )\n    call netcdf_nullify_data_struct( NCFILE=this%NCFILE_ARCHIVE )\n\n  end subroutine initialize_constant_real_data_object_sub\n\n!----------------------------------------------------------------------\n\n  subroutine initialize_constant_int_data_object_sub( &\n    this, &\n    sDescription, &\n    iConstant )\n\n    class (T_DATA_GRID) :: this\n    character (len=*) :: sDescription\n    integer (kind=c_int), intent(in) :: iConstant\n\n    this%iConstantValue = iConstant\n    this%sDescription = trim(sDescription)\n    this%iSourceDataForm = CONSTANT_GRID\n    this%iSourceDataType = DATATYPE_INT\n    this%iTargetDataType = DATATYPE_INT\n    this%iSourceFileType = FILETYPE_NONE\n\n    call netcdf_nullify_data_struct( NCFILE=this%NCFILE )\n    call netcdf_nullify_data_struct( NCFILE=this%NCFILE_ARCHIVE )\n\n  end subroutine initialize_constant_int_data_object_sub\n\n!----------------------------------------------------------------------\n\nsubroutine initialize_gridded_data_object_sub( &\n   this, &\n   sDescription, &\n   sFileType, &\n   iDataType, &\n   sFilename, &\n   sFilenameTemplate, &\n   sPROJ4)\n\n   class (T_DATA_GRID) :: this\n   type ( T_GENERAL_GRID ),pointer :: pGrd\n   character (len=*) :: sDescription\n   character (len=*) :: sFileType\n   character (len=*), optional :: sFilename\n   integer (kind=c_int) :: iDataType\n   character (len=*), optional :: sFilenameTemplate\n   character (len=*), optional :: sPROJ4\n\n   if (present(sPROJ4) ) then\n     this%sSourcePROJ4_string = trim(sPROJ4)\n     if(.not. str_compare(sPROJ4, pGrd%sPROJ4_string) ) &\n         this%lProjectionDiffersFromBase = lTRUE\n   else\n     this%sSourcePROJ4_string =  \"\"\n   endif\n\n   if (present(sFilename)) then\n     this%sSourceFilename = sFilename\n     this%iSourceDataForm = STATIC_GRID\n   else\n     this%sSourceFilename = \"\"\n   endif\n\n   if (present(sFilenameTemplate)) then\n     this%sFilenameTemplate = sFilenameTemplate\n     this%sSourceFilename = \"\"\n     this%iSourceDataForm = DYNAMIC_GRID\n     this%lGridIsPersistent = lTRUE\n   else\n     this%sFilenameTemplate = \"\"\n   endif\n\n   call assert(.not. (len_trim(this%sSourceFilename) > 0 &\n      .and. len_trim(this%sFilenameTemplate) > 0), &\n      \"INTERNAL PROGRAMMING ERROR - values may be assigned to either \" &\n      //dquote(\"Filename\")//\" or the \"//dquote(\"sFilenameTemplate\") &\n      //\" -- NOT BOTH!\", trim(__FILE__), __LINE__)\n\n   this%sSourceFileType = sFileType\n   this%iSourceFileType = this%get_filetype()\n\n   this%iSourceDataType = iDataType\n   this%iTargetDataType = iDataType\n\n   this%sDescription = trim(sDescription)\n\n  call assert(this%iSourceFileType == FILETYPE_ARC_ASCII .or. &\n    this%iSourceFileType == FILETYPE_SURFER, \"Only Arc ASCII or \" &\n    //\"Surfer grids are supported as static grid inputs (for now).\", &\n    trim(__FILE__), __LINE__)\n\n  call assert(this%iSourceDataType == DATATYPE_INT .or. &\n    this%iSourceDataType == DATATYPE_REAL, \"Only integer or \" &\n    //\"real data types are supported as static grid inputs.\", &\n    trim(__FILE__), __LINE__)\n\n  nullify(this%pGrdNative)\n  call netcdf_nullify_data_struct( NCFILE=this%NCFILE )\n  call netcdf_nullify_data_struct( NCFILE=this%NCFILE_ARCHIVE )\n\nend subroutine initialize_gridded_data_object_sub\n\n!----------------------------------------------------------------------\n\nsubroutine initialize_netcdf_data_object_sub( &\n   this, &\n   sDescription, &\n   iDataType, &\n   pGrdBase, &\n   sFilename, &\n   sFilenameTemplate, &\n   sPROJ4)\n\n   class (T_DATA_GRID) :: this\n   character (len=*) :: sDescription\n   integer (kind=c_int) :: iDataType\n   type ( T_GENERAL_GRID ),pointer :: pGrdBase\n   character (len=*), optional :: sFilename\n   character (len=*), optional :: sFilenameTemplate\n   character (len=*), optional :: sPROJ4\n\n   if (present(sPROJ4) ) then\n     this%sSourcePROJ4_string = trim(sPROJ4)\n   else\n     this%sSourcePROJ4_string =  \"\"\n   endif\n\n   if (present(sFilename)) then\n     this%sSourceFilename = sFilename\n     this%iSourceDataForm = STATIC_NETCDF_GRID\n     this%lGridIsPersistent = lFALSE\n   else\n     this%sSourceFilename = \"\"\n   endif\n\n   if (present(sFilenameTemplate)) then\n     this%sFilenameTemplate = sFilenameTemplate\n     this%sSourceFilename = \"\"\n     this%lGridIsPersistent = lTRUE\n     this%iSourceDataForm = DYNAMIC_NETCDF_GRID\n   else\n     this%sFilenameTemplate = \"\"\n   endif\n\n   call assert(.not. (len_trim(this%sSourceFilename) > 0 &\n      .and. len_trim(this%sFilenameTemplate) > 0), &\n      \"INTERNAL PROGRAMMING ERROR - values may be assigned to either \" &\n      //dquote(\"Filename\")//\" or the \"//dquote(\"sFilenameTemplate\") &\n      //\" -- NOT BOTH!\", trim(__FILE__), __LINE__)\n\n   this%sSourceFileType = \"NETCDF\"\n   this%iSourceFileType = this%get_filetype()\n\n   this%iTargetDataType = iDataType\n   this%iNC_FILE_STATUS = NETCDF_FILE_CLOSED\n\n   call netcdf_nullify_data_struct( NCFILE=this%NCFILE )\n   call netcdf_nullify_data_struct( NCFILE=this%NCFILE_ARCHIVE )\n\nend subroutine initialize_netcdf_data_object_sub\n\n!----------------------------------------------------------------------\n\n  subroutine getvalues_sub( this, pGrdBase, iMonth, iDay, iYear, iJulianDay, &\n    iValues, rValues)\n\n    class (T_DATA_GRID) :: this\n    type ( T_GENERAL_GRID ), pointer :: pGrdBase\n    integer (kind=c_int), intent(in), optional :: iMonth, iDay, iYear, iJulianDay\n    integer (kind=c_int), dimension(:,:), optional :: iValues\n    real (kind=c_float), dimension(:,:), optional :: rValues\n\n    ! [ LOCALS ]\n    integer (kind=c_int) :: iNumDaysToPad\n    integer (kind=c_int) :: iPadDays\n    integer (kind=c_int) :: iLocalJulianDay\n\n    if(this%iSourceDataForm == DYNAMIC_GRID ) then\n\n      call getvalues_gridded_sub( this, pGrdBase, iMonth, iDay, iYear)\n\n\n    elseif ( this%iSourceDataForm == DYNAMIC_NETCDF_GRID ) then\n\n      iLocalJulianDay = iJulianDay\n      call getvalues_dynamic_netcdf_sub( this, &\n                           pGrdBase,  iMonth, iDay, iYear, iLocalJulianDay)\n\n\n    elseif(this%iSourceDataForm == STATIC_GRID ) then\n\n      call getvalues_gridded_sub( this, pGrdBase)\n\n    elseif(this%iSourceDataForm == CONSTANT_GRID ) then\n\n      call getvalues_constant_sub( this, pGrdBase )\n\n    else\n\n      call assert(lFALSE, \"Unsupported data source specified\", &\n        trim(__FILE__), __LINE__)\n\n    endif\n\n    if (present(rValues)) then\n\n       rValues = ( pGrdBase%rData * this%rScaleFactor + this%rAddOffset ) * this%rConversionFactor\n\n    endif\n\n    if (present(iValues)) then\n\n        iValues = ( pGrdBase%iData * int(this%rScaleFactor, kind=c_int)  &\n                                  + int(this%rAddOffset,kind=c_int) ) * this%rConversionFactor\n    endif\n\n  end subroutine getvalues_sub\n\n!----------------------------------------------------------------------\n\nsubroutine getvalues_constant_sub( this, pGrdBase )\n\n  class (T_DATA_GRID) :: this\n  type ( T_GENERAL_GRID ), pointer :: pGrdBase\n\n  select case (this%iSourceDataType)\n\n    case ( DATATYPE_REAL )\n\n      pGrdBase%rData = this%rConstantValue\n\n    case ( DATATYPE_INT)\n\n      pGrdBase%iData = this%iConstantValue\n\n    case default\n\n      call dump_data_structure_sub(this)\n\n      call assert(lFALSE, \"INTERNAL PROGRAMMING ERROR - Unhandled data type: \" &\n        //\"name=\"//dquote(this%sDescription) &\n        //\"; value=\"//trim(asCharacter(this%iSourceDataType)), &\n        trim(__FILE__), __LINE__)\n\n    end select\n\n  end subroutine getvalues_constant_sub\n\n!----------------------------------------------------------------------\n\n  subroutine dump_data_structure_sub(this)\n\n  class (T_DATA_GRID) :: this\n\n  call echolog(\"---------------------------------------------------\")\n  call echolog(\"DATA STRUCTURE DETAILS:\")\n  call echolog(\"---------------------------------------------------\")\n\n  call echolog(\"  source data form: \"//trim(asCharacter(this%iSourceDataForm)) )\n  call echolog(\"  source data type: \"//trim(asCharacter(this%iSourceDataType)) )\n  call echolog(\"  source file type: \"//trim(asCharacter(this%iSourceFileType)) )\n  call echolog(\"  description: \"//trim(this%sDescription) )\n  call echolog(\"  source PROJ4 string: \"//trim(this%sSourcePROJ4_string) )\n  call echolog(\"  source file type: \"//trim(this%sSourceFileType) )\n  call echolog(\"  filename template: \"//trim(this%sFilenameTemplate) )\n  call echolog(\"  source filename: \"//trim(this%sSourceFilename) )\n\n  if (associated(this%pGrdNative))  call grid_DumpGridExtent(this%pGrdNative)\n\n  end subroutine dump_data_structure_sub\n\n!----------------------------------------------------------------------\n\n  subroutine getvalues_gridded_sub( this, pGrdBase, iMonth, iDay, iYear)\n\n    class (T_DATA_GRID) :: this\n    type ( T_GENERAL_GRID ), pointer :: pGrdBase\n    integer (kind=c_int), optional :: iMonth\n    integer (kind=c_int), optional :: iDay\n    integer (kind=c_int), optional :: iYear\n    logical (kind=c_bool) :: lExist\n    logical (kind=c_bool) :: lOpened\n\n    this%lGridHasChanged = lFALSE\n\n    do\n\n      call assert(this%iSourceFileType == FILETYPE_ARC_ASCII .or. &\n        this%iSourceFileType == FILETYPE_SURFER, \"INTERNAL PROGRAMMING ERROR -\" &\n        //\" improper file type in use for a call to this subroutine\", &\n        trim(__FILE__), __LINE__)\n\n      if ( len_trim(this%sFilenameTemplate) > 0 ) then\n        if(.not. (present(iMonth) .and. present(iDay) .and. present(iYear) ) ) &\n          call assert(lFALSE, \"INTERNAL PROGRAMMING ERROR - month, day, and year\" &\n            //\" arguments must be supplied when calling this subroutine in a \" &\n            //\"dynamic mode.\", trim(__FILE__), __LINE__)\n        call this%make_filename(iMonth, iDay, iYear)\n      endif\n\n      ! if the source filename hasn't changed, we don't need to be here\n      if (str_compare(this%sOldFilename, this%sSourceFilename) ) exit\n\n      this%sOldFilename = this%sSourceFilename\n\n      inquire(file=this%sSourceFilename, exist=lExist, opened=lOpened)\n      !!! if the file doesn't exist, EXIT!\n      if (.not. lExist ) then\n        if ( this%lMissingFilesAreAllowed ) then\n         exit\n        else\n          call assert( lFALSE, &\n            \"Could not find input data file~filename:\"//dquote(this%sSourceFilename) &\n            //\"~data description: \"//trim(this%sDescription))\n        endif\n      endif\n\n      if ( this%lGridIsPersistent .and. associated(this%pGrdNative) ) then\n\n        call grid_ReadExisting ( sFileName=this%sSourceFilename, &\n          sFileType=this%sSourceFileType, &\n          pGrd=this%pGrdNative )\n\n      else\n\n        ! create a grid in native coordinates of the source dataset.\n        this%pGrdNative => grid_Read( sFileName=this%sSourceFilename, &\n          sFileType=this%sSourceFileType, &\n          iDataType=this%iSourceDataType )\n\n        ! ensure that PROJ4 string is associated with the native grid\n        this%pGrdNative%sPROJ4_string = this%sSourcePROJ4_string\n\n      endif\n\n      write( unit=LU_LOG, fmt=\"(a)\") \"Opened file \"//dQuote(this%sSourceFilename) &\n        //\" for \"//trim(this%sDescription)//\" data.\"\n\n      this%lGridHasChanged = lTRUE\n\n      select case (this%iTargetDataType)\n\n        case ( GRID_DATATYPE_REAL )\n\n          call this%handle_missing_values(this%pGrdNative%rData)\n          call this%enforce_limits(this%pGrdNative%rData)\n\n        case ( GRID_DATATYPE_INT )\n\n!          call this%handle_missing_values(this%pGrdNative%iData)\n!          call this%enforce_limits(this%pGrdNative%iData)\n\n        case default\n\n          call assert(lFALSE, \"INTERNAL PROGRAMMING ERROR - Unhandled data type: value=\" &\n            //trim(asCharacter(this%iSourceDataType)), &\n            trim(__FILE__), __LINE__)\n\n      end select\n\n      call this%transfer_from_native( pGrdBase )\n\n      if (.not. this%lGridIsPersistent )  call grid_Destroy(this%pGrdNative)\n\n      exit\n\n    enddo\n\n  end subroutine getvalues_gridded_sub\n\n!----------------------------------------------------------------------\n\nsubroutine transform_grid_to_grid(this, pGrdBase)\n\n    class (T_DATA_GRID) :: this\n    type ( T_GENERAL_GRID ), pointer :: pGrdBase\n\n    if( len_trim( this%sSourcePROJ4_string ) > 0 ) then\n\n      ! only invoke the transform procedure if the PROJ4 strings are different\n      if (.not. str_compare(this%pGrdNative%sPROJ4_string, pGrdBase%sPROJ4_string)) then\n\n        call echolog(\" \")\n        call echolog(\"Transforming gridded data in file: \"//dquote(this%sSourceFilename) )\n        call echolog(\"  FROM: \"//squote(this%sSourcePROJ4_string) )\n        call echolog(\"  TO:   \"//squote(pGrdBase%sPROJ4_string) )\n\n        call grid_Transform(pGrd=this%pGrdNative, &\n                          sFromPROJ4=this%sSourcePROJ4_string, &\n                          sToPROJ4=pGrdBase%sPROJ4_string )\n\n      endif\n\n      call Assert( grid_CompletelyCover( pGrdBase, this%pGrdNative ), &\n        \"Transformed grid read from file \"//dquote(this%sSourceFilename) &\n        //\" doesn't completely cover your model domain.\")\n\n      select case (this%iTargetDataType)\n\n        case ( GRID_DATATYPE_REAL )\n\n          call grid_gridToGrid(pGrdFrom=this%pGrdNative,&\n                              rArrayFrom=this%pGrdNative%rData, &\n                              pGrdTo=pGrdBase, &\n                              rArrayTo=pGrdBase%rData )\n\n        case ( GRID_DATATYPE_INT )\n\n          call grid_gridToGrid(pGrdFrom=this%pGrdNative,&\n                            iArrayFrom=this%pGrdNative%iData, &\n                            pGrdTo=pGrdBase, &\n                            iArrayTo=pGrdBase%iData )\n        case default\n\n          call assert(lFALSE, \"INTERNAL PROGRAMMING ERROR - Unhandled data type: value=\" &\n            //trim(asCharacter(this%iSourceDataType)), &\n            trim(__FILE__), __LINE__)\n\n      end select\n\n    else\n\n      call Assert( grid_Conform( pGrdBase, this%pGrdNative ), &\n                        \"Non-conforming grid. Filename: \" &\n                        //dquote(this%pGrdNative%sFilename) )\n\n      select case (this%iTargetDataType)\n\n        case ( GRID_DATATYPE_REAL )\n\n          pGrdBase%rData = this%pGrdNative%rData\n\n        case ( GRID_DATATYPE_INT)\n\n          pGrdBase%iData = this%pGrdNative%iData\n\n        case default\n\n          call assert(lFALSE, \"INTERNAL PROGRAMMING ERROR - Unhandled data type: value=\" &\n              //trim(asCharacter(this%iSourceDataType)), &\n            trim(__FILE__), __LINE__)\n\n      end select\n\n    endif\n\nend subroutine transform_grid_to_grid\n\n!----------------------------------------------------------------------\n\nsubroutine set_constant_value_int( this, iValue )\n\n    class (T_DATA_GRID) :: this\n    integer (kind=c_int) :: iValue\n\n    this%iConstantValue = iValue\n\nend subroutine set_constant_value_int\n\n!----------------------------------------------------------------------\n\nsubroutine set_constant_value_real( this, rValue )\n\n    class (T_DATA_GRID) :: this\n    real (kind=c_float) :: rValue\n\n    this%rConstantValue = rValue\n\nend subroutine set_constant_value_real\n\n!----------------------------------------------------------------------\n\n  subroutine set_filecount( this, iValue, iYear)\n\n    class (T_DATA_GRID) :: this\n    integer (kind=c_int) :: iValue\n    integer (kind=c_int), optional :: iYear\n\n    this%iFileCount = iValue\n\n    if (present(iYear) ) this%iFileCountYear = iYear\n\n  end subroutine set_filecount\n\n!----------------------------------------------------------------------\n\n  subroutine increment_filecount( this )\n\n    class (T_DATA_GRID) :: this\n\n    this%iFileCount = this%iFileCount + 1\n\n  end subroutine increment_filecount\n\n!----------------------------------------------------------------------\n\n  subroutine reset_filecount( this )\n\n    class (T_DATA_GRID) :: this\n\n    this%iFileCount = 0\n\n  end subroutine reset_filecount\n\n!----------------------------------------------------------------------\n\n  subroutine reset_at_yearend_filecount( this, iYear )\n\n    class (T_DATA_GRID) :: this\n    integer (kind=c_int) :: iYear\n\n    if (iYear /= this%iFileCountYear )  then\n      this%iFileCount = 0\n      this%iFileCountYear = iYear\n    endif\n\n  end subroutine reset_at_yearend_filecount\n\n!----------------------------------------------------------------------\n\n  subroutine make_filename_from_template( this, iMonth, iDay, iYear )\n\n    class (T_DATA_GRID) :: this\n    integer (kind=c_int), optional :: iMonth, iDay, iYear\n\n    ! [ LOCALS ]\n    character (len=256) :: sNewFilename\n    character (len=256) :: sUppercaseFilename\n    character (len=256) :: sCWD\n    character (len=256) :: sBuf2\n    integer (kind=c_int) :: iPos_Y, iPos_D, iPos_M, iPos, iPos2, iLen, iCount\n    integer (kind=c_int) :: iNumZeros, iNumZerosToPrint\n    logical (kind=c_bool) :: lMatch\n    logical (kind=c_bool) :: lExist\n    character (len=2) :: sBuf\n    character (len=12) :: sNumber\n    character (len=1) :: sDelimiter\n    integer (kind=c_int) :: iStatus\n\n    iPos_Y = 0; iPos_M = 0; iPos_D = 0; iPos = 0; sNumber = \"\"\n\n    ! EXAMPLES of the kinds of templates that we need to be able to understand:\n    ! tars1980\\prcp.nc   template => \"tars%Y\\prcp.nc\"\n    ! prcp_1980_00.nc    template => \"prcp_%Y_%m.nc\"\n\n    iStatus = getcwd(sCWD )\n\n    call assert(iStatus==0, \"Problem detemining what the current working\" &\n      //\" directory is\", trim(__FILE__), __LINE__)\n\n    sNewFilename = this%sFilenameTemplate\n\n    iCount = 0\n\n    do\n\n      lMatch = lFALSE\n\n      if (present(iYear) ) iPos_Y = &\n           max(index(sNewFilename, \"%Y\"), index(sNewFilename, \"%y\") )\n\n      if (iPos_Y > 0) then\n        lMatch = lTRUE\n        iLen=len_trim(sNewFilename)\n        sNewFilename = sNewFilename(1:iPos_Y - 1)//trim(asCharacter(iYear)) &\n                       //sNewFilename(iPos_Y + 2:iLen)\n\n      endif\n\n      iPos = index(sNewFilename, \"#\")\n\n      if (iPos > 0) then\n\n        iPos2 = index(sNewFilename(1:iPos),\"%\", BACK=lTRUE)\n        sBuf2 = trim(asCharacter(this%iFileCount))\n        iNumZeros = max(0, iPos - iPos2 - 1)\n\n        if (iNumZeros > 0) then\n          iNumZerosToPrint = max(0,iNumZeros - len_trim(sBuf2) + 1)\n          sNumber = repeat(\"0\", iNumZerosToPrint )//trim(sBuf2)\n        else\n          sNumber = repeat(\"0\", iNumZeros - len_trim(sBuf2) )//trim(sBuf2)\n        endif\n\n        lMatch = lTRUE\n        iLen=len_trim(sNewFilename)\n        sNewFilename = sNewFilename(1:iPos-2-iNumZeros)//trim(sNumber) &\n                       //sNewFilename(iPos+1:iLen)\n      endif\n\n      if (present(iMonth) ) iPos_M = &\n          max(index(sNewFilename, \"%M\"), index(sNewFilename, \"%m\") )\n\n      if (iPos_M > 0) then\n        lMatch = lTRUE\n        write (unit=sBuf, fmt=\"(i2.2)\") iMonth\n\n        iLen=len_trim(sNewFilename)\n        sNewFilename = sNewFilename(1:iPos_M - 1)//sBuf &\n                       //sNewFilename(iPos_M + 2:iLen)\n      endif\n\n      if (present(iDay) ) iPos_D = &\n           max(index(sNewFilename, \"%D\"),index(sNewFilename, \"%d\") )\n\n      if (iPos_D > 0) then\n        lMatch = lTRUE\n        write (unit=sBuf, fmt=\"(i2.2)\") iDay\n        iLen=len_trim(sNewFilename)\n        sNewFilename = sNewFilename(1:iPos_D - 1)//sBuf &\n                       //sNewFilename(iPos_D + 2:iLen)\n      endif\n\n      if (.not. lMatch) exit\n\n      iCount = iCount + 1\n\n      ! failsafe\n      if (iCount > 4) exit\n\n    enddo\n\n    if( index(string=sCWD, substring=\"/\") > 0 ) then\n      sDelimiter = \"/\"\n    else\n      sDelimiter = \"\\\"\n    endif\n\n!    this%sSourceFilename = trim(sCWD)//trim(sDelimiter)//trim(sNewFilename)\n    this%sSourceFilename = trim(sNewFilename)\n\n  end subroutine make_filename_from_template\n\n!----------------------------------------------------------------------\n\n  function test_for_need_to_pad_values(this, iMonth, iDay, iYear ) &\n                                            result(lNeedToPadData)\n\n    class (T_DATA_GRID) :: this\n    integer (kind=c_int) :: iMonth, iDay, iYear\n\n    ! [ LOCALS ]\n    logical (kind=c_bool) :: lExist\n    integer (kind=c_int) :: iDaysLeftInMonth\n    integer (kind=c_int) :: iPos\n    logical (kind=c_bool) :: lNeedToPadData\n\n    do\n\n      lNeedToPadData = lFALSE\n\n      iPos = scan(string=trim(this%sSourceFilename), set=\"http://\")\n\n      !> if this is a URL, we don't want to test for file existence using\n      !> the Fortran \"inquire\" function\n      if (this%sSourceFilename(iPos:iPos+6) == \"http://\") then\n\n        exit\n\n      else\n\n        ! does this file actually exist?\n        inquire( file=this%sSourceFilename, exist=lExist )\n\n        !> if the file exists, don't bother with padding any values\n        if (lExist) exit\n\n        !> if file doesn't exist, and we're close to the end of the year,\n        !> assume that we should pad values at the end of the year\n        if (iMonth == 12 ) then\n\n          iDaysLeftInMonth = 31 - iDay\n\n          if (isLeap(iYear)) then\n\n            if ( iDaysLeftInMonth <= this%iDaysToPadIfLeapYear ) then\n\n              lNeedToPadData = lTRUE\n              exit\n\n            endif\n\n          else    ! it's not leap year\n\n            if ( iDaysLeftInMonth <= this%iDaysToPadAtYearsEnd ) then\n\n              lNeedToPadData = lTRUE\n              exit\n\n            endif\n\n          endif\n\n        endif\n\n        !> if we've reached this point, we cannot locate the proper file and\n        !> we are not within the proper range of dates to allow for padding.\n        call assert(lExist, \"The filename created from your template refers to \" &\n          //\"a nonexistent file. ~ Attempted to open filename \"&\n          //dquote(this%sSourceFilename), trim(__FILE__), __LINE__)\n\n        exit\n\n      endif\n\n    enddo\n\n\n  end function test_for_need_to_pad_values\n\n!----------------------------------------------------------------------\n\n  subroutine getvalues_dynamic_netcdf_sub( this, pGrdBase, &\n     iMonth, iDay, iYear, iJulianDay)\n\n    class (T_DATA_GRID) :: this\n    type ( T_GENERAL_GRID ), pointer :: pGrdBase\n    integer (kind=c_int) :: iMonth, iDay, iYear, iJulianDay\n\n    ! [ LOCALS ]\n    integer (kind=c_int) :: iTimeIndex\n    integer (kind=c_int) :: iStat\n    logical (kind=c_bool) :: lDateTimeFound\n\n    this%lPadValues = lFALSE\n\n    ! call once at start of run...\n    if ( this%iFileCountYear < 0 ) call this%set_filecount(-1, iYear)\n\n    if (this%iNC_FILE_STATUS == NETCDF_FILE_OPEN) then\n\n      ! check to see whether currently opened file is within date range\n      ! if past date range, close file\n\n      if ( .not. netcdf_date_within_range(NCFILE=this%NCFILE, iJulianDay=iJulianDay ) ) then\n        call netcdf_close_file( NCFILE=this%NCFILE )\n        this%iNC_FILE_STATUS = NETCDF_FILE_CLOSED\n      endif\n\n    endif\n\n    if ( this%iNC_FILE_STATUS == NETCDF_FILE_CLOSED ) then\n\n      ! increment or reset file counter based on current year value\n\n      call this%increment_filecount()\n\n      call this%reset_at_yearend_filecount(iYear)\n\n      call this%make_filename( iMonth=iMonth, iYear=iYear, iDay=iDay)\n\n      this%lPadValues = this%test_for_need_to_pad_values(iMonth=iMonth, iYear=iYear, iDay=iDay)\n\n       !> call to test_for_need_to_pad_values return value of \"TRUE\" if\n      !> if attempts to open a nonexistent file within the last few days of a year.\n      !> The assumption is that values missing at the end of a calendar year\n      !> translates into a missing file at the year's end\n\n      if (.not. this%lPadValues) then\n\n        if (this%lPerformFullInitialization ) then\n\n          if( len_trim( this%sSourcePROJ4_string ) > 0 ) then\n\n            !> calculate the project boundaries in the coordinate system of\n            !> the native data file\n            call this%calc_project_boundaries(pGrdBase=pGrdBase)\n\n            call netcdf_open_and_prepare_as_input(NCFILE=this%NCFILE, &\n              sFilename=this%sSourceFilename, &\n              lFlipHorizontal=this%lFlipHorizontal, &\n              lFlipVertical=this%lFlipVertical, &\n              sVariableOrder=this%sVariableOrder, &\n              sVarName_x=this%sVariableName_x, &\n              sVarName_y=this%sVariableName_y, &\n              sVarName_z=this%sVariableName_z, &\n              sVarName_time=this%sVariableName_time, &\n              tGridBounds=this%GRID_BOUNDS, &\n              iLU=LU_LOG)\n\n          else  ! PROJ4 string is blank\n\n            !> assume source NetCDF file is in same projection and\n            !> of same dimensions as base grid\n            call netcdf_open_and_prepare_as_input(NCFILE=this%NCFILE, &\n              sFilename=this%sSourceFilename, &\n              lFlipHorizontal=this%lFlipHorizontal, &\n              lFlipVertical=this%lFlipVertical, &\n              sVariableOrder=this%sVariableOrder, &\n              sVarName_x=this%sVariableName_x, &\n              sVarName_y=this%sVariableName_y, &\n              sVarName_z=this%sVariableName_z, &\n              sVarName_time=this%sVariableName_time, &\n              iLU=LU_LOG)\n\n            this%NCFILE%iNX = pGrdBase%iNX\n            this%NCFILE%iNY = pGrdBase%iNY\n            this%NCFILE%rX(NC_LEFT) = pGrdBase%rX0\n            this%NCFILE%rY(NC_BOTTOM) = pGrdBase%rY0\n            this%NCFILE%rX(NC_RIGHT) = pGrdBase%rX1\n            this%NCFILE%rY(NC_TOP) = pGrdBase%rY1\n\n          endif\n\n          this%iNC_FILE_STATUS = NETCDF_FILE_OPEN\n\n          this%iSourceDataType = this%NCFILE%iVarType(NC_Z)\n\n          !> if the user has not supplied a scale and offset,\n          !> then populate these values with the scale and offset\n          !> factor included in the NetCDF attribute data, if any.\n          if (.not. this%lUserSuppliedScaleAndOffset) then\n            this%rAddOffset = this%NCFILE%rAddOffset(NC_Z)\n            this%rScaleFactor = this%NCFILE%rScaleFactor(NC_Z)\n          endif\n\n          !> Amongst other things, the call to netcdf_open_and_prepare\n          !> finds the nearest column and row that correspond to the\n          !> project bounds, then back-calculates the coordinate values\n          !> of the column and row numbers in the *NATIVE* coordinate system\n          this%pGrdNative => grid_CreateComplete ( iNX=this%NCFILE%iNX, &\n                    iNY=this%NCFILE%iNY, &\n                    rX0=this%NCFILE%rX(NC_LEFT), &\n                    rY0=this%NCFILE%rY(NC_BOTTOM), &\n                    rX1=this%NCFILE%rX(NC_RIGHT), &\n                    rY1=this%NCFILE%rY(NC_TOP), &\n                    iDataType=this%iTargetDataType )\n\n          if( len_trim( this%sSourcePROJ4_string ) > 0 ) then\n            ! ensure that PROJ4 string is associated with the native grid\n            this%pGrdNative%sPROJ4_string = this%sSourcePROJ4_string\n          endif\n\n          this%pGrdNative%sFilename = this%sSourceFilename\n\n          this%lPerformFullInitialization = lFALSE\n\n        else\n          !> Projection settings can be left alone; read values from new\n          !> NetCDF file with same grid boundaries, projection, etc.\n\n!          call netcdf_open_file(NCFILE=this%NCFILE, sFilename=this%sSourceFilename, iLU=LU_LOG)\n          call netcdf_open_file(NCFILE=this%NCFILE, sFilename=this%sSourceFilename)\n\n          this%iNC_FILE_STATUS = NETCDF_FILE_OPEN\n\n        endif\n\n        if (.not. netcdf_date_within_range(NCFILE=this%NCFILE, iJulianDay=iJulianDay) ) then\n\n          call echolog(\"Valid date range (NetCDF): \"//trim(asCharacter(this%NCFILE%iFirstDayJD)) &\n            //\" to \"//trim(asCharacter(this%NCFILE%iLastDayJD)) )\n\n          call echolog(\"Current Julian Day value: \"//trim(asCharacter(iJulianDay)) )\n\n          call assert (lFALSE, \"Date range for currently open NetCDF file\" &\n            //\" does not include the present simulation date.\", &\n            trim(__FILE__), __LINE__)\n\n        endif\n\n      endif   ! if(lPadValues)\n\n    endif  ! If (NC_FILE_STATUS == NETCDF_CLOSED)\n\n    if (.not. this%lPadValues) then\n\n      do\n        lDateTimeFound = netcdf_update_time_starting_index(NCFILE=this%NCFILE, &\n                                         iJulianDay=iJulianDay)\n\n        if (.not. lDateTimeFound) then\n          this%lPadValues = lTRUE\n          exit\n        endif\n\n        call netcdf_get_variable_slice(NCFILE=this%NCFILE, rValues=this%pGrdNative%rData)\n        call this%handle_missing_values(this%pGrdNative%rData)\n        call this%enforce_limits(this%pGrdNative%rData)\n        exit\n      enddo\n\n    endif\n\n    if (this%lPadValues) then\n\n      if (this%lPadReplaceWithZero) then\n\n        this%pGrdNative%rData = 0_c_float\n        this%pGrdNative%iData = 0_c_int\n\n      endif\n\n      call echolog( repeat(\"=\", 60) )\n      call echolog( \"Missing day found in NetCDF file - padding values\" )\n!      call stats_WriteMinMeanMax( iLU=LU_STD_OUT, &\n!        sText=trim(this%NCFILE%sFilename), &\n!        rData=this%pGrdNative%rData)\n!      call stats_WriteMinMeanMax( iLU=LU_LOG, &\n!        sText=trim(this%NCFILE%sFilename), &\n!        rData=this%pGrdNative%rData)\n      call echolog( repeat(\"=\", 60) )\n\n    endif\n\n    if (this%lCreateLocalNetCDFArchive) &\n             call this%put_values_to_archive(iMonth, iDay, iYear)\n\n    call this%transfer_from_native( pGrdBase )\n\n  end subroutine getvalues_dynamic_netcdf_sub\n\n!----------------------------------------------------------------------\n\n  subroutine put_values_to_local_NetCDF_sub(this, iMonth, iDay, iYear)\n\n    class (T_DATA_GRID) :: this\n    integer (kind=c_int) :: iMonth\n    integer (kind=c_int) :: iDay\n    integer (kind=c_int) :: iYear\n\n    ! [ LOCALS ]\n    integer (kind=c_size_t) :: iNumRows, iNumCols, iNumRecs\n\n    if (this%iNC_ARCHIVE_STATUS == NETCDF_FILE_CLOSED) then\n\n      call netcdf_open_and_prepare_as_output(NCFILE=this%NCFILE, &\n               NCFILE_ARCHIVE=this%NCFILE_ARCHIVE, &\n               iOriginMonth=iMonth, iOriginDay=iDay, iOriginYear=iYear, &\n               iStartYear=this%iStartYear, iEndYear=this%iEndYear)\n\n      this%iNC_ARCHIVE_STATUS = NETCDF_FILE_OPEN\n\n    endif\n\n    iNumRows = int(size(this%pGrdNative%rData, 2), kind=c_size_t)\n    iNumCols = int(size(this%pGrdNative%rData, 1), kind=c_size_t)\n    iNumRecs = this%iNCFILE_RECNUM\n\n    call netcdf_put_variable_array(NCFILE=this%NCFILE_ARCHIVE, &\n       iVarID=this%NCFILE_ARCHIVE%iVarID(NC_Z), &\n       iStart=[iNumRecs, 0_c_size_t, 0_c_size_t], &\n       iCount=[1_c_size_t, iNumRows, iNumCols], &\n       iStride=[1_c_ptrdiff_t,1_c_ptrdiff_t,1_c_ptrdiff_t], &\n       rValues=this%pGrdNative%rData)\n\n    call netcdf_put_variable_vector(NCFILE=this%NCFILE_ARCHIVE, &\n       iVarID=this%NCFILE_ARCHIVE%iVarID(NC_TIME), &\n       iStart=[this%iNCFILE_RECNUM], &\n       iCount=[1_c_size_t], &\n       iStride=[1_c_size_t], &\n       dpValues=[real(this%iNCFILE_RECNUM, kind=c_double)])\n\n    this%iNCFILE_RECNUM = this%iNCFILE_RECNUM + 1\n\n  end subroutine put_values_to_local_NetCDF_sub\n\n!----------------------------------------------------------------------\n\n  function get_source_filetype_fn(this)  result(iFileType)\n\n     class (T_DATA_GRID) :: this\n     integer (kind=c_int) :: iFileType\n\n     if (str_compare(this%sSourceFileType, \"ARC_GRID\") ) then\n\n       iFileType = FILETYPE_ARC_ASCII\n\n     elseif (str_compare(this%sSourceFileType, \"SURFER\") ) then\n\n       iFileType = FILETYPE_SURFER\n\n     elseif (str_compare(this%sSourceFileType, \"NETCDF\") ) then\n\n       iFileType = FILETYPE_NETCDF\n\n     else\n\n       call assert(lFALSE, \"Unknown input file type specified. ~\"&\n         //\"  filename: \"//dquote(this%sSourceFilename) &\n         //\"~  file type specified as: \"//dquote(this%sSourceFileType), &\n         trim(__FILE__), __LINE__)\n\n     endif\n\n  end function get_source_filetype_fn\n\n!----------------------------------------------------------------------\n\n  subroutine set_PROJ4_string_sub(this, sPROJ4_string)\n\n     class (T_DATA_GRID) :: this\n     character (len=*), optional :: sPROJ4_string\n\n     this%sSourcePROJ4_string = sPROJ4_string\n\n  end subroutine set_PROJ4_string_sub\n\n!----------------------------------------------------------------------\n\n  subroutine set_grid_flip_horizontal_sub(this)\n\n    class (T_DATA_GRID) :: this\n\n    this%lFlipHorizontal = lTRUE\n\n  end subroutine set_grid_flip_horizontal_sub\n\n!----------------------------------------------------------------------\n\n  subroutine set_grid_flip_vertical_sub(this)\n\n    class (T_DATA_GRID) :: this\n\n    this%lFlipVertical = lTRUE\n\n  end subroutine set_grid_flip_vertical_sub\n\n!----------------------------------------------------------------------\n\n  subroutine set_variable_order_sub(this, sVariableOrder)\n\n    class (T_DATA_GRID) :: this\n    character (len=*) :: sVariableOrder\n\n    this%sVariableOrder = sVariableOrder\n\n  end subroutine set_variable_order_sub\n\n!----------------------------------------------------------------------\n\nsubroutine set_scale_sub(this, rScaleFactor)\n\n   class (T_DATA_GRID) :: this\n   real (kind=c_float) :: rScaleFactor\n\n   this%rScaleFactor = rScaleFactor\n   this%lUserSuppliedScaleAndOffset = lTRUE\n\nend subroutine set_scale_sub\n\n!----------------------------------------------------------------------\n\nsubroutine set_conversion_factor_sub(this, rConversionFactor)\n\n   class (T_DATA_GRID) :: this\n   real (kind=c_float) :: rConversionFactor\n\n   this%rConversionFactor = rConversionFactor\n\nend subroutine set_conversion_factor_sub\n\n!----------------------------------------------------------------------\n\nsubroutine set_archive_local_sub(this, lValue)\n\n   class (T_DATA_GRID) :: this\n   logical (kind=c_bool) :: lValue\n\n   this%lCreateLocalNetCDFArchive = lValue\n\nend subroutine set_archive_local_sub\n\n!----------------------------------------------------------------------\n\nsubroutine set_offset_sub(this, rAddOffset)\n\n   class (T_DATA_GRID) :: this\n   real (kind=c_float) :: rAddOffset\n\n   this%rAddOffset = rAddOffset\n   this%lUserSuppliedScaleAndOffset = lTRUE\n\nend subroutine set_offset_sub\n\n!----------------------------------------------------------------------\n\nsubroutine set_missing_value_int_sub(this, iMissingVal)\n\n  class (T_DATA_GRID) :: this\n  integer (kind=c_int) :: iMissingVal\n\n  this%iMissingValuesCode = iMissingVal\n\nend subroutine set_missing_value_int_sub\n\n!----------------------------------------------------------------------\n\nsubroutine set_missing_value_real_sub(this, rMissingVal)\n\n  class (T_DATA_GRID) :: this\n  integer (kind=c_int) :: rMissingVal\n\n  this%rMissingValuesCode = rMissingVal\n\nend subroutine set_missing_value_real_sub\n\n!----------------------------------------------------------------------\n\nsubroutine set_minimum_allowable_value_int_sub(this, iMinVal)\n\n  class (T_DATA_GRID) :: this\n  integer (kind=c_int) :: iMinVal\n\n  this%iMinAllowedValue = iMinVal\n\nend subroutine set_minimum_allowable_value_int_sub\n\n!----------------------------------------------------------------------\n\nsubroutine set_maximum_allowable_value_int_sub(this, iMaxVal)\n\n  class (T_DATA_GRID) :: this\n  integer (kind=c_int) :: iMaxVal\n\n  this%iMaxAllowedValue = iMaxVal\n\nend subroutine set_maximum_allowable_value_int_sub\n\n!----------------------------------------------------------------------\n\nsubroutine set_minimum_allowable_value_real_sub(this, rMinVal)\n\n  class (T_DATA_GRID) :: this\n  real (kind=c_float) :: rMinVal\n\n  this%rMinAllowedValue = rMinVal\n\nend subroutine set_minimum_allowable_value_real_sub\n\n!----------------------------------------------------------------------\n\nsubroutine set_maximum_allowable_value_real_sub(this, rMaxVal)\n\n  class (T_DATA_GRID) :: this\n  real (kind=c_float) :: rMaxVal\n\n  this%rMaxAllowedValue = rMaxVal\n\nend subroutine set_maximum_allowable_value_real_sub\n\n!----------------------------------------------------------------------\n\n  subroutine calc_project_boundaries(this, pGrdBase)\n\n    class (T_DATA_GRID) :: this\n    type ( T_GENERAL_GRID ), pointer :: pGrdBase\n\n    ! [ LOCALS ]\n    integer (kind=c_int) :: iRetVal\n    real (kind=c_float) :: rMultiplier = 1.5\n    real (kind=c_double), dimension(4) :: rX, rY\n\n    ! ensure that there is sufficient coverage on all sides of grid\n    rX(1) = pGrdBase%rX0 - pGrdBase%rGridCellSize * rMultiplier ! Xll\n    rY(1) = pGrdBase%rY0 - pGrdBase%rGridCellSize * rMultiplier ! Yll\n    rX(2) = pGrdBase%rX1 + pGrdBase%rGridCellSize * rMultiplier ! Xlr\n    rY(2) = pGrdBase%rY0 - pGrdBase%rGridCellSize * rMultiplier ! Ylr\n    rX(3) = pGrdBase%rX0 - pGrdBase%rGridCellSize * rMultiplier ! Xul\n    rY(3) = pGrdBase%rY1 + pGrdBase%rGridCellSize * rMultiplier ! Yul\n    rX(4) = pGrdBase%rX1 + pGrdBase%rGridCellSize * rMultiplier ! Xur\n    rY(4) = pGrdBase%rY1 + pGrdBase%rGridCellSize * rMultiplier ! Yur\n\n    ! now transform the project coordinates to native coordinates so we can\n    ! use the native coordinate boundaries to \"cookie-cut\" only the data\n    ! pertinent to our project area.\n    iRetVal = pj_init_and_transform(trim(pGrdBase%sPROJ4_string)//C_NULL_CHAR, &\n                trim(this%sSourcePROJ4_string)//C_NULL_CHAR, 4_c_long, &\n                rX, rY )\n\n  call grid_CheckForPROJ4Error(iRetVal=iRetVal, &\n     sFromPROJ4=trim(pGrdBase%sPROJ4_string), &\n     sToPROJ4=trim(this%sSourcePROJ4_string))\n\n  !> because PROJ4 works in RADIANS if data are unprojected (i.e. GEOGRAPHIC),\n  !> we need to convert back to degrees on the assumption that the coordinates\n  !> referenced in the file will also be i degrees\n  if( index(string=trim(this%sSourcePROJ4_string), substring=\"latlon\") > 0 &\n      .or. index(string=trim(this%sSourcePROJ4_string), substring=\"lonlat\") > 0 ) then\n\n    rX = rad2deg(rX)\n    rY = rad2deg(rY)\n\n  endif\n\n   this%GRID_BOUNDS%rXll = rX(1); this%GRID_BOUNDS%rXlr = rX(2)\n   this%GRID_BOUNDS%rYll = rY(1); this%GRID_BOUNDS%rYlr = rY(2)\n   this%GRID_BOUNDS%rXul = rX(3); this%GRID_BOUNDS%rXur = rX(4)\n   this%GRID_BOUNDS%rYul = rY(3); this%GRID_BOUNDS%rYur = rY(4)\n\n#ifdef DEBUG_PRINT\n   print *, \" \"\n   print *, \"--  BASE GRID BOUNDS projected to DATA NATIVE COORDS\"\n   print *, \"FROM: \", dquote(pGrdBase%sPROJ4_string)\n   print *, \"TO:   \", dquote(this%sSourcePROJ4_string)\n   PRINT *, \"file: \", dquote(this%sSourceFileName)\n   print *, \"            X                            Y\"\n   print *, \"LL: \", this%GRID_BOUNDS%rXll, this%GRID_BOUNDS%rYll\n   print *, \"LR: \", this%GRID_BOUNDS%rXlr, this%GRID_BOUNDS%rYlr\n   print *, \"UL: \", this%GRID_BOUNDS%rXul, this%GRID_BOUNDS%rYul\n   print *, \"UR: \", this%GRID_BOUNDS%rXur, this%GRID_BOUNDS%rYur\n#endif\n\n  end subroutine calc_project_boundaries\n\n!----------------------------------------------------------------------\n\n  subroutine data_GridEnforceLimits_int(this, iValues)\n\n    class (T_DATA_GRID) :: this\n    integer (kind=c_int), dimension(:,:) :: iValues\n\n    ! [ LOCALS ]\n    integer (kind=c_int) :: iMin, iMax\n\n    iMin = this%iMinAllowedValue\n    iMax = this%iMaxAllowedValue\n\n    where ( iValues < iMin )  iValues = iMin\n    where ( iValues > iMax )  iValues = iMax\n\n  end subroutine data_GridEnforceLimits_int\n\n!----------------------------------------------------------------------\n\n  subroutine data_GridEnforceLimits_real(this, rValues)\n\n    class (T_DATA_GRID) :: this\n    real (kind=c_float), dimension(:,:) :: rValues\n\n    ! [ LOCALS ]\n    real (kind=c_float) :: rMin, rMax\n\n    rMin = real(this%rMinAllowedValue, kind=c_float)\n    rMax = real(this%rMaxAllowedValue, kind=c_float)\n\n    where ( rValues < rMin )  rValues = rMin\n    where ( rValues > rMax )  rValues = rMax\n\n  end subroutine data_GridEnforceLimits_real\n\n!----------------------------------------------------------------------\n\n  subroutine data_GridHandleMissingData_real(this, rValues)\n\n    class (T_DATA_GRID) :: this\n    real (kind=c_float), dimension(:,:), intent(inout) :: rValues\n\n    ! [ LOCALS ]\n    real (kind=c_float) :: rMissing, rMean\n\n    rMissing = real(this%rMissingValuesCode, kind=c_float)\n\n    select case (this%iMissingValuesAction)\n\n      case (MISSING_VALUES_ZERO_OUT)\n\n        select case (trim(this%sMissingValuesOperator))\n\n          case (\"<=\")\n\n            where (rValues <= rMissing) rValues = rZERO\n\n          case (\"<\")\n\n            where (rValues < rMissing) rValues = rZERO\n\n          case (\">=\")\n\n            where (rValues >= rMissing) rValues = rZERO\n\n          case (\">\")\n\n            where (rValues > rMissing) rValues = rZERO\n\n          case default\n\n            call assert(lFALSE, \"Unknown missing values code was supplied \" &\n              //\"for processing data \"//squote(this%sDescription)//\": \" &\n              //dquote(this%sMissingValuesOperator) )\n\n          end select\n\n      case (MISSING_VALUES_REPLACE_WITH_MEAN)\n\n        select case (this%sMissingValuesOperator)\n\n          case (\"<=\")\n\n            rMean = sum(rValues, rValues > rMissing ) &\n               / count(rValues > rMissing )\n\n            where (rValues <= rMissing) rValues = rMean\n\n          case (\"<\")\n\n            rMean = sum(rValues, rValues >= rMissing ) &\n               / count(rValues >= rMissing )\n\n            where (rValues < rMissing) rValues = rMean\n\n          case (\">=\")\n\n            rMean = sum(rValues, rValues < rMissing ) &\n               / count(rValues < rMissing )\n\n            where (rValues >= rMissing) rValues = rMean\n\n          case (\">\")\n\n            rMean = sum(rValues, rValues <= rMissing ) &\n               / count(rValues <= rMissing )\n\n            where (rValues > rMissing) rValues = rMean\n\n          case default\n\n            call assert(lFALSE, \"Unknown missing values code was supplied \" &\n              //\"for processing data \"//squote(this%sDescription)//\": \" &\n              //dquote(this%sMissingValuesOperator) )\n\n          end select\n\n      case default\n\n        call assert(lFALSE, \"INTERNAL PROGRAMMING ERROR - unhandled iMissingValuesAction\", &\n        trim(__FILE__), __LINE__)\n\n    end select\n\n  end subroutine data_GridHandleMissingData_real\n\n!----------------------------------------------------------------------\n\n  subroutine data_GridHandleMissingData_int(this, iValues)\n\n    class (T_DATA_GRID) :: this\n    integer (kind=c_int), dimension(:,:), intent(inout) :: iValues\n\n    ! [ LOCALS ]\n    integer (kind=c_int) :: iMissing, iMean\n\n    iMissing = this%iMissingValuesCode\n\n    select case (this%iMissingValuesAction)\n\n      case (MISSING_VALUES_ZERO_OUT)\n\n        select case (trim(this%sMissingValuesOperator))\n\n          case (\"<=\")\n\n            where (iValues <= iMissing) iValues = iZERO\n\n          case (\"<\")\n\n            where (iValues < iMissing) iValues = iZERO\n\n          case (\">=\")\n\n            where (iValues >= iMissing) iValues = iZERO\n\n          case (\">\")\n\n            where (iValues > iMissing) iValues = iZERO\n\n          case default\n\n            call assert(lFALSE, \"Unknown missing values code was supplied \" &\n              //\"for processing data \"//squote(this%sDescription)//\": \" &\n              //dquote(this%sMissingValuesOperator) )\n\n          end select\n\n      case (MISSING_VALUES_REPLACE_WITH_MEAN)\n\n        select case (this%sMissingValuesOperator)\n\n          case (\"<=\")\n\n            iMean = sum(iValues, iValues > iMissing ) &\n               / count(iValues > iMissing )\n\n            where (iValues <= iMissing) iValues = iMean\n\n          case (\"<\")\n\n            iMean = sum(iValues, iValues >= iMissing ) &\n               / count(iValues >= iMissing )\n\n            where (iValues < iMissing) iValues = iMean\n\n          case (\">=\")\n\n            iMean = sum(iValues, iValues < iMissing ) &\n               / count(iValues < iMissing )\n\n            where (iValues >= iMissing) iValues = iMean\n\n          case (\">\")\n\n            iMean = sum(iValues, iValues <= iMissing ) &\n               / count(iValues <= iMissing )\n\n            where (iValues > iMissing) iValues = iMean\n\n          case default\n\n            call assert(lFALSE, \"Unknown missing values code was supplied \" &\n              //\"for processing data \"//squote(this%sDescription)//\": \" &\n              //dquote(this%sMissingValuesOperator) )\n\n          end select\n\n      case default\n\n        call assert(lFALSE, \"INTERNAL PROGRAMMING ERROR - unhandled iMissingValuesAction\", &\n        trim(__FILE__), __LINE__)\n\n    end select\n\n  end subroutine data_GridHandleMissingData_int\n\nend module data_factory\n",
			"file": "/Users/smwesten/SMWData/Source_Code/swb/src/data_factory.F90",
			"file_size": 52756,
			"file_write_time": 130335091420000000,
			"settings":
			{
				"buffer_size": 52755,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/smwesten/SMWData/Source_Code/swb/cmake/print_summary.cmake",
			"settings":
			{
				"buffer_size": 2106,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/Users/smwesten/SMWData/Source_Code/swb/cmake/find_programs_and_libraries.cmake",
			"settings":
			{
				"buffer_size": 4154,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/smwesten/SMWData/Source_Code/swb/build/mac_osx/gfortran/run_cmake_gfortran.sh",
			"settings":
			{
				"buffer_size": 3006,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 392.0
	},
	"console":
	{
		"height": 153.0,
		"history":
		[
			"ls"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Users/smwesten/SMWData/Source_Code/swb/eclipse_projects/swb/src/graph.F90",
		"/Users/smwesten/Library/Application Support/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/Users/smwesten/SMWData/Source_Code/swb/src/control.F90",
		"/Users/smwesten/Library/Application Support/Sublime Text 3/Packages/Default/Preferences.sublime-settings",
		"/Users/smwesten/SMWData/Source_Code/swb/CMakeLists_orig.txt",
		"/Users/smwesten/SMWData/Source_Code/swb/build/osx/gfortran/run_cmake_gfortran.sh",
		"/Users/smwesten/SMWData/Source_Code/swb/CMakeLists.txt",
		"/Users/smwesten/SMWData/Source_Code/swb/CMakeLists_new.txt",
		"/Users/smwesten/SMWData/Source_Code/swb/build/win_x64/gfortran/run_cmake_mingw_gfortran.bat",
		"/Users/smwesten/SMWData/Source_Code/swb/src/netcdf_support.F90",
		"/Users/smwesten/SMWData/Documents/MMD/test/manuscript.mmd",
		"/Users/smwesten/SMWData/Documents/MMD/test2/pandoc_readme.mmd",
		"/Users/smwesten/SMWData/Documents/MMD/test2/sample.lua",
		"/Users/smwesten/SMWData/Visual_Identity/usgslatexdist_original/latex/scripts/dvtable_example/usgsdvtable_builder.pl",
		"/Users/smwesten/SMWData/Documents/LaTeX/scripts/csv_to_latex.py",
		"/Users/smwesten/SMWData/Documents/LaTeX/SWB_Documentation_TM6-A31/tables/LU_LOOKUP_NLCD.txt",
		"/Users/smwesten/SMWData/Visual_Identity/univers_fontinst/build-funivers-script.perl",
		"/Users/smwesten/DefaultKeyBinding.dict",
		"/Users/smwesten/SMWData/Source_Code/swb/src/et_blaney_criddle.F90",
		"/Users/smwesten/Library/Application Support/Sublime Text 3/Packages/User/Perl.sublime-settings",
		"/Users/smwesten/Library/Application Support/Sublime Text 3/Packages/User/fortran.tmbundle-master/Syntaxes/Fortran - Modern.tmLanguage"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"LIB_PATH",
			"/gfortran/",
			"MINGW_VERSION",
			"MINGWBASE",
			"win_x64",
			"\\t",
			"c8a",
			"pun",
			"afm"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"/${Fortran_COMPILER_NAME}/",
			"COMPILER_VERSION",
			"COMPILER_DIR",
			"${OS}",
			"    ",
			"8a",
			"fun",
			"pfb"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 3,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/Users/smwesten/SMWData/Source_Code/swb/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3318,
						"regions":
						{
						},
						"selection":
						[
							[
								2452,
								2452
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1116.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/Users/smwesten/SMWData/Source_Code/swb/tests/general/CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1269,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Batch File/Batch File.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/Users/smwesten/SMWData/Source_Code/swb/src/model.F90",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 145121,
						"regions":
						{
						},
						"selection":
						[
							[
								134864,
								134864
							]
						],
						"settings":
						{
							"syntax": "Packages/User/fortran.tmbundle-master/Syntaxes/Fortran - Modern.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 2.0,
						"translation.y": 67916.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "/Users/smwesten/SMWData/Source_Code/swb/src/data_factory.F90",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 52755,
						"regions":
						{
						},
						"selection":
						[
							[
								12,
								12
							]
						],
						"settings":
						{
							"syntax": "Packages/User/fortran.tmbundle-master/Syntaxes/Fortran - Modern.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1990.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/Users/smwesten/SMWData/Source_Code/swb/cmake/print_summary.cmake",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2106,
						"regions":
						{
						},
						"selection":
						[
							[
								1533,
								1533
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 62.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/Users/smwesten/SMWData/Source_Code/swb/cmake/find_programs_and_libraries.cmake",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4154,
						"regions":
						{
						},
						"selection":
						[
							[
								3075,
								3075
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2012.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/Users/smwesten/SMWData/Source_Code/swb/build/mac_osx/gfortran/run_cmake_gfortran.sh",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3006,
						"regions":
						{
						},
						"selection":
						[
							[
								760,
								760
							]
						],
						"settings":
						{
							"syntax": "Packages/ShellScript/Shell-Unix-Generic.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 78.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"project": "swb_cmake.sublime-project",
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"",
				"~/SMWData/Source_Code/swb/src/types.F90"
			],
			[
				"read",
				"~/SMWData/Source_Code/swb/src/et_blaney_criddle.F90"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 674.0
	},
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": false,
	"side_bar_visible": true,
	"side_bar_width": 244.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
